/*
 *  drivers/mtd/nand_bbt.c
 *
 *  Overview:
 *   Bad block table support for the NAND driver
 *
 *  Copyright (C) 2004 Thomas Gleixner (tglx@linutronix.de)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * Description:
 *
 * When nand_scan_bbt is called, then it tries to find the bad block table
 * depending on the options in the bbt descriptor(s). If a bbt is found
 * then the contents are read and the memory based bbt is created. If a
 * mirrored bbt is selected then the mirror is searched too and the
 * versions are compared. If the mirror has a greater version number
 * than the mirror bbt is used to build the memory based bbt.
 * If the tables are not versioned, then we "or" the bad block information.
 * If one of the bbt's is out of date or does not exist it is (re)created.
 * If no bbt exists at all then the device is scanned for factory marked
 * good / bad blocks and the bad block tables are created.
 *
 * For manufacturer created bbts like the one found on M-SYS DOC devices
 * the bbt is searched and read but never created
 *
 * The autogenerated bad block table is located in the last good blocks
 * of the device. The table is mirrored, so it can be updated eventually.
 * The table is marked in the oob area with an ident pattern and a version
 * number which indicates which of both tables is more up to date.
 *
 * The table uses 2 bits per block
 * 11b:	block is good
 * 00b:	block is factory marked bad
 * 01b, 10b:	block is marked bad due to wear
 *
 * The memory bad block table uses the following scheme:
 * 00b:		block is good
 * 01b:		block is marked bad due to wear
 * 10b:		block is reserved (to protect the bbt area)
 * 11b:		block is factory marked bad
 *
 * Multichip devices like DOC store the bad block info per floor.
 *
 * Following assumptions are made:
 * - bbts start at a page boundary, if autolocated on a block boundary
 * - the space necessary for a bbt in FLASH does not exceed a block boundary
 *
 */

#include <common.h>
#include <malloc.h>
#include <linux/crc32.h>
#include <linux/mtd/compat.h>
#include <linux/mtd/mtd.h>
#include <linux/mtd/nand.h>

#include <asm/errno.h>

#ifdef CONFIG_MTD_UBI_BACKUP_LSB
#include "../../mstar/unfd/inc/common/drvNAND.h"
#endif

#if (ENABLE_MODULE_SPI_NAND_FLASH == 1)
#include "../../mstar/spinand/inc/common/spinand.h"
extern SPI_NAND_DRIVER_t gtSpiNandDrv;
#endif
		
/**
 * check_pattern - [GENERIC] check if a pattern is in the buffer
 * @buf:	the buffer to search
 * @len:	the length of buffer to search
 * @paglen:	the pagelength
 * @td:		search pattern descriptor
 *
 * Check for a pattern at the given place. Used to search bad block
 * tables and good / bad block identifiers.
 * If the SCAN_EMPTY option is set then check, if all bytes except the
 * pattern area contain 0xff
 *
*/
static int check_pattern(uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)
{
	int i, end = 0;
	uint8_t *p = buf;

	end = paglen + td->offs;
	if (td->options & NAND_BBT_SCANEMPTY) {
		for (i = 0; i < end; i++) {
			if (p[i] != 0xff)
				return -1;
		}
	}
	p += end;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
		if (p[i] != td->pattern[i])
			return -1;
	}

	if (td->options & NAND_BBT_SCANEMPTY) {
		p += td->len;
		end += td->len;
		for (i = end; i < len; i++) {
			if (*p++ != 0xff)
				return -1;
		}
	}
	return 0;
}

int nand_switchto_mem_bbt(struct mtd_info *mtd);

int check_space_bbt(struct mtd_info *mtd, struct nand_bbt_descr *td, struct nand_bbt_descr *md, int chipsel)
{
        struct nand_chip *chippr = mtd->priv;
        int chip = 0;
        int startblock, dir, page, numblocks, i;
        int nrchips;
    
        /* Write bad block table per chip rather than per device ? */
        if (td->options & NAND_BBT_PERCHIP) {
            numblocks = (int)(chippr->chipsize >> chippr->bbt_erase_shift);
            /* Full device write or specific chip ? */
            if (chipsel == -1) {
                nrchips = chippr->numchips;
            } else {
                    nrchips = chipsel + 1;
                    chip = chipsel;
                }
        } else {
                numblocks = (int)(mtd->size >> chippr->bbt_erase_shift);
                nrchips = 1;
            }

        /* Loop through the chips */
        for (; chip < nrchips; chip++) {

                /* There was already a version of the table, reuse the page
                * This applies for absolute placement too, as we have the
                * page nr. in td->pages.
                */
                if (td->pages[chip][0] != -1) {
                    page = td->pages[chip][0];
                    return 1;
                }

                /* Automatic placement of the bad block table */
                /* Search direction top -> down ? */
                if (td->options & NAND_BBT_LASTBLOCK) {
                    startblock = numblocks * (chip + 1) - 1;
                    dir = -1;
                } else {
                    startblock = chip * numblocks;
                    dir = 1;
                }

                for (i = 0; i < td->maxblocks; i++) {
                    int block = startblock + dir * i;
                    int offs = block << chippr->bbt_erase_shift;
/*                    printk("bbt_erase_shift=%d\n",this->bbt_erase_shift);
                    printk("offs:0x%08x\n",offs);
                    printk("block num: %d\n",block);
                    printk("%x\n",(this->bbt[block >> 2] >>
                        (2 * (block & 0x03))) & 0x03);*/
                    
                    /* Check, if the block is bad */
                    if(chippr->block_bad(mtd, offs, 0))
                        continue;
                    page = block <<
                        (chippr->bbt_erase_shift - chippr->page_shift);
                    /* Check, if the block is used by the mirror table */
                    if ((!md) || (md->pages[chip][0] != page))
                        return 1;
                }
        
                printk(KERN_ERR "No space left to write bad block table\n");
        }
        nand_switchto_mem_bbt(mtd);   
        return 0;
}

int check_bbt_consistency(struct mtd_info *mtd, struct nand_bbt_descr *td, struct nand_bbt_descr *md, int chipsel)
{
        struct nand_chip *chippr = mtd->priv;
        int i, chip = 0;
        int startblock, dir, numblocks;
        int nrchips;
    
        /* Write bad block table per chip rather than per device ? */
        if (td->options & NAND_BBT_PERCHIP) {
            numblocks = (int)(chippr->chipsize >> chippr->bbt_erase_shift);
            /* Full device write or specific chip ? */
            if (chipsel == -1) {
                nrchips = chippr->numchips;
            } else {
                nrchips = chipsel + 1;
                chip = chipsel;
            }
        } else {
            numblocks = (int)(mtd->size >> chippr->bbt_erase_shift);
            nrchips = 1;
        }

        /* Loop through the chips */
        for (; chip < nrchips; chip++) {
                /* There was already a version of the table, reuse the page
                * This applies for absolute placement too, as we have the
                * page nr. in td->pages.
                */

                /* Search direction top -> down ? */
                if (td->options & NAND_BBT_LASTBLOCK) {
                    startblock = numblocks * (chip + 1) - 1;
                    dir = -1;
                } else {
                    startblock = chip * numblocks;
                    dir = 1;
                }
                for (i = 0; i < numblocks; i++) {
                    int block = startblock + dir * i;
                    int blockofs = block << chippr->bbt_erase_shift;
                    /* Check, if the block is bad */
                    switch ((chippr->bbt[block >> 2] >>
                            (2 * (block & 0x03))) & 0x03) {
                    case 0x01:              
                    case 0x03:
                            if(chippr->block_bad(mtd, blockofs, 0))
                                chippr->block_markbad(mtd, blockofs);
                            break;                
                    default: 
                            break;
                    }       
                }
        
       }
       return 0;
}
/**
 * check_short_pattern - [GENERIC] check if a pattern is in the buffer
 * @buf:	the buffer to search
 * @td:		search pattern descriptor
 *
 * Check for a pattern at the given place. Used to search bad block
 * tables and good / bad block identifiers. Same as check_pattern, but
 * no optional empty check
 *
*/
static int check_short_pattern(uint8_t *buf, struct nand_bbt_descr *td)
{
	int i;
	uint8_t *p = buf;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
		if (p[td->offs + i] != td->pattern[i])
			return -1;
	}
	return 0;
}

/**
 * check_short_pattern - [GENERIC] check if a pattern is in the buffer
 * @buf:	the buffer to search
 * @td:		search pattern descriptor
 *
 * Check for a pattern at the given place. Used to search bad block
 * tables and good / bad block identifiers. Same as check_pattern, but
 * no optional empty check
 *
*/
static int check_short_pattern_specify(uint8_t *buf, struct nand_bbt_descr *td, int page)
{
	int i;
	uint8_t *p = buf;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
		if (p[td->BBtMarkerOffs[page]+ i] != td->pattern[i])
			return -1;
	}
	return 0;
}

static int _read_bbt (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
{
        int err;
    
        err = mtd->read(mtd, from, len, retlen, buf);
        if (err){
                if (err == -EUCLEAN) {
                    /*
                    * -EUCLEAN is reported if there was a bit-flip which
                    * was corrected, so this is harmless.
                    *
                    * We do not report about it here unless debugging is
                    * enabled. A corresponding message will be printed
                    * later, when it is has been scrubbed.
                    */
                    if (*retlen != len) {
                            printk(KERN_INFO "nand_bbt: Error reading bad block table1\n");
                            return -ECOMM;
                    }
                    return err;
                }

/*              if (*retlen != len && retries++ < NAND_RETRIES) {
                    goto retry;
                    }

                 if (*retlen == len &&  err == -EBADMSG && retries++ < NAND_RETRIES) {
                goto retry;
                }*/

                printk(KERN_INFO "nand_bbt: Error reading bad block table2\n");
                return -ECOMM;

                }else {
                    if (*retlen != len) {
                        printk(KERN_INFO "nand_bbt: Error reading bad block table3\n");
                        return -ECOMM;
                }

        }

        return err; 
}

/**
 * read_bbt - [GENERIC] Read the bad block table starting from page
 * @mtd:	MTD device structure
 * @buf:	temporary buffer
 * @page:	the starting page
 * @num:	the number of bbt descriptors to read
 * @bits:	number of bits per block
 * @offs:	offset in the memory table
 * @reserved_block_code:	Pattern to identify reserved blocks
 *
 * Read the bad block table starting from page.
 *
 */
static int read_bbt(struct mtd_info *mtd, uint8_t *buf, int page, int num,
		    int bits, int offs, int reserved_block_code)
{
	int res, i, j, act = 0, bbtpagenum = 0;
	struct nand_chip *this = mtd->priv;
	size_t retlen, len, totlen;
	loff_t from, bbtpage;
	uint8_t msk = (uint8_t) ((1 << bits) - 1);
    int retries = 0, scrub = 0, bitflip = 0;
    struct erase_info einfo;
    
	totlen = (num * bits) >> 3;
	from = ((loff_t) page) << this->page_shift;

	while (totlen) {
		len = min(totlen, (size_t) (1 << this->page_shift));
#ifdef CONFIG_MTD_UBI_BACKUP_LSB                
            bbtpage = from  + ga_tPairedPageMap[bbtpagenum].u16_LSB * mtd->writesize;
#else
            bbtpage = from  + bbtpagenum * mtd->writesize;
#endif        
            res = _read_bbt(mtd, bbtpage, len, &retlen, buf);
            if (res) {
                if (res == -EUCLEAN) {
                    scrub = 1;
                    bitflip = 1;
                } else if (res == -ECOMM) {
                    scrub = 1;
                    } else{
                        goto out_retry;
                    }
                }
        
            if (scrub){
            
retry_erase:            
                memset(&einfo, 0, sizeof(einfo));
                einfo.mtd = mtd;
                einfo.addr = (unsigned long)from;
                einfo.len = 1 << this->bbt_erase_shift;
                res = nand_erase_nand(mtd, &einfo, 1);
        
                if ((res<0) && (retries<NAND_RETRIES)){
                    retries++;
                    goto retry_erase;
                 }
            
                /*erase error, mark the bbt block bad. so it should rescan the device and update the bbt */                  
                if(retries >= NAND_RETRIES)
                {
                    if(NAND_STATUS_HWFAIL == einfo.state){
                        printk("Erase fail, mark the block bad!\n");
                        this->block_markbad(mtd, (loff_t)from);
                        printk( "nand_erase: "
                            "mark block 0x%llx bad\n", from);
                    }    
                    goto outerr;
                }
            
                if((retries >= NAND_RETRIES) || (!bitflip))
                    goto outerr;
              }

out_retry:

		/* Analyse data */
		for (i = 0; i < len; i++) {
			uint8_t dat = buf[i];
			for (j = 0; j < 8; j += bits, act += 2) {
				uint8_t tmp = (dat >> j) & msk;
				if (tmp == msk)
					continue;
				if (reserved_block_code && (tmp == reserved_block_code)) {
					printk(KERN_DEBUG "nand_read_bbt: Reserved block at 0x%012llx\n",
						(loff_t)((offs << 2) +
						(act >> 1)) <<
						this->bbt_erase_shift);
					this->bbt[offs + (act >> 3)] |= 0x2 << (act & 0x06);
					mtd->ecc_stats.bbtblocks++;
					continue;
				}
				/* Leave it for now, if its matured we can move this
				 * message to MTD_DEBUG_LEVEL0 */
				printk(KERN_DEBUG "nand_read_bbt: Bad block at 0x%012llx\n",
					(loff_t)((offs << 2) + (act >> 1)) <<
					this->bbt_erase_shift);
				/* Factory marked bad or worn out ? */
				if (tmp == 0)
					this->bbt[offs + (act >> 3)] |= 0x3 << (act & 0x06);
				else
					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
				mtd->ecc_stats.badblocks++;
			}
		}
		totlen -= len;
		bbtpagenum ++;
	}
	return 0;
    
outerr:
        printk(KERN_WARNING
        "nand_bbt: Error while reading bad block table %d\n", res);
        return res;     
}

/**
 * read_abs_bbt - [GENERIC] Read the bad block table starting at a given page
 * @mtd:	MTD device structure
 * @buf:	temporary buffer
 * @td:		descriptor for the bad block table
 * @chip:	read the table for a specific chip, -1 read all chips.
 *		Applies only if NAND_BBT_PERCHIP option is set
 *
 * Read the bad block table for all chips starting at a given page
 * We assume that the bbt bits are in consecutive order.
*/
static int read_abs_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td, int chip)
{
	struct nand_chip *this = mtd->priv;
	int res = 0, i;
	int bits;

	bits = td->options & NAND_BBT_NRBITS_MSK;
	if (td->options & NAND_BBT_PERCHIP) {
		int offs = 0;
		for (i = 0; i < this->numchips; i++) {
			if (chip == -1 || chip == i)
				res = read_bbt (mtd, buf, td->pages[i][0], this->chipsize >> this->bbt_erase_shift, bits, offs, td->reserved_block_code);
			if (res)
				return res;
			offs += this->chipsize >> (this->bbt_erase_shift + 2);
		}
	} else {
		res = read_bbt (mtd, buf, td->pages[0][0], mtd->size >> this->bbt_erase_shift, bits, 0, td->reserved_block_code);
		if (res)
			return res;
	}
	return 0;
}

/*
 * Scan read raw data from flash
 */
static int scan_read_raw(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
			 size_t len)
{
	struct mtd_oob_ops ops;

	ops.ooboffs = 0;
	ops.datbuf = buf;
	ops.len = len;

	if(mtd->ecclayout->oobfree[0].length < 4)//BBT Pattern Length
	{
		ops.mode = MTD_OOB_AUTO;
		ops.ooblen = mtd->oobavail;
        ops.oobbuf = buf + len;
	}
    else
    {
		ops.mode = MTD_OOB_RAW;
		ops.ooblen = mtd->oobsize;
        ops.oobbuf = buf; 
    }


	return mtd->read_oob(mtd, offs, &ops);
}

#if (ENABLE_MODULE_NAND_FLASH == 1)
/*
 * Scan read raw data from flash
 */
static int scan_read_hwecc(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
			 size_t len)
{
	struct mtd_oob_ops ops;

	ops.mode = MTD_OOB_PLACE;
	ops.ooboffs = 0;
	ops.ooblen = mtd->oobsize;
	ops.oobbuf = buf;
	ops.datbuf = buf;
	ops.len = len;

	return mtd->read_oob(mtd, offs, &ops);
}
#endif

/*
 * Scan write data with oob to flash
 */
static int scan_write_bbt(struct mtd_info *mtd, loff_t offs, size_t len,
			  uint8_t *buf, uint8_t *oob)
{
	struct mtd_oob_ops ops;

	ops.ooboffs = 0;
	ops.datbuf = buf;
	ops.oobbuf = oob;
	ops.len = len;

	if(mtd->ecclayout->oobfree[0].length < 4)//BBT Pattern Length
	{
		ops.mode = MTD_OOB_AUTO;
		ops.ooblen = mtd->oobavail;
	}
    else
    {
		ops.mode = MTD_OOB_PLACE;
		ops.ooblen = mtd->oobsize;
    }


	return mtd->write_oob(mtd, offs, &ops);
}

/**
 * read_abs_bbts - [GENERIC] Read the bad block table(s) for all chips starting at a given page
 * @mtd:	MTD device structure
 * @buf:	temporary buffer
 * @td:		descriptor for the bad block table
 * @md:		descriptor for the bad block table mirror
 *
 * Read the bad block table(s) for all chips starting at a given page
 * We assume that the bbt bits are in consecutive order.
 *
*/
static int read_abs_bbts(struct mtd_info *mtd, uint8_t *buf,
			 struct nand_bbt_descr *td, struct nand_bbt_descr *md)
{
	struct nand_chip *this = mtd->priv;

	/* Read the primary version, if available */
	if (td->options & NAND_BBT_VERSION) {
		scan_read_raw(mtd, buf, (loff_t)td->pages[0][0] <<
				this->page_shift, mtd->writesize);
		td->version[0] = buf[mtd->writesize + td->veroffs];
		printk(KERN_DEBUG "Bad block table at page %d, version 0x%02X\n",
		       td->pages[0][0], td->version[0]);
	}

	/* Read the mirror version, if available */
	if (md && (md->options & NAND_BBT_VERSION)) {
		scan_read_raw(mtd, buf, (loff_t)md->pages[0][0] <<
				this->page_shift, mtd->writesize);
		md->version[0] = buf[mtd->writesize + md->veroffs];
		printk(KERN_DEBUG "Bad block table at page %d, version 0x%02X\n",
		       md->pages[0][0], md->version[0]);
	}
	return 1;
}

/*
 * Scan a given block full
 */
static int scan_block_full(struct mtd_info *mtd, struct nand_bbt_descr *bd,
			   loff_t offs, uint8_t *buf, size_t readlen,
			   int scanlen, int len)
{
	int ret, j;

	ret = scan_read_raw(mtd, buf, offs, readlen);
	if (ret)
		return ret;

	for (j = 0; j < len; j++, buf += scanlen) {
		if (check_pattern(buf, scanlen, mtd->writesize, bd))
			return 1;
	}
	return 0;
}

/*
 * Scan a given block partially
 */
static int scan_block_fast(struct mtd_info *mtd, struct nand_bbt_descr *bd,
			   loff_t offs, uint8_t *buf, int len)
{
	struct mtd_oob_ops ops;
	int j, ret;

	ops.ooblen = mtd->oobsize;
	ops.oobbuf = buf;
	ops.ooboffs = 0;
	ops.datbuf = NULL;
	ops.mode = MTD_OOB_PLACE;

	for (j = 0; j < len; j++) {
		/*
		 * Read the full oob until read_oob is fixed to
		 * handle single byte reads for 16 bit
		 * buswidth
		 */
		ret = mtd->read_oob(mtd, offs, &ops);
		if (ret)
			return ret;

		if (check_short_pattern(buf, bd))
			return 1;

		offs += mtd->writesize;
	}
	return 0;
}

/*
 * Scan a given block partially
 */
static int scan_block_specific(struct mtd_info *mtd, struct nand_bbt_descr *bd,
			   loff_t offs, uint8_t *buf, int len)
{
	struct mtd_oob_ops ops;
	int j, ret;

	ops.ooblen = mtd->oobsize;
	ops.oobbuf = buf;
	ops.ooboffs = 0;
	ops.datbuf = NULL;
	ops.mode = MTD_OOB_PLACE;

	for (j = 0; j <bd->BBtMarkerPageCount; j++) {
		/*
		 * Read the full oob until read_oob is fixed to
		 * handle single byte reads for 16 bit
		 * buswidth
		 */
		ret = mtd->read_oob(mtd, offs + (bd->BBtMarkerPage[j] * mtd->writesize), &ops);
		if (ret)
			return ret;

		if (check_short_pattern_specify(buf, bd, j))
			return 1;
	}
	return 0;
}

/**
 * create_bbt - [GENERIC] Create a bad block table by scanning the device
 * @mtd:	MTD device structure
 * @buf:	temporary buffer
 * @bd:		descriptor for the good/bad block search pattern
 * @chip:	create the table for a specific chip, -1 read all chips.
 *		Applies only if NAND_BBT_PERCHIP option is set
 *
 * Create a bad block table by scanning the device
 * for the given good/bad block identify pattern
 */
static int create_bbt(struct mtd_info *mtd, uint8_t *buf,
	struct nand_bbt_descr *bd, int chip)
{
	struct nand_chip *this = mtd->priv;
	int i, numblocks, len, scanlen;
	int startblock;
	loff_t from;
	size_t readlen;

	MTDDEBUG (MTD_DEBUG_LEVEL0, "Scanning device for bad blocks\n");

	if (bd->options & NAND_BBT_SCANALLPAGES)
		len = 1 << (this->bbt_erase_shift - this->page_shift);
	else {
		if (bd->options & NAND_BBT_SCAN2NDPAGE)
			len = 2;
		else
			len = 1;
	}

	if (!(bd->options & NAND_BBT_SCANEMPTY)) {
		/* We need only read few bytes from the OOB area */
		scanlen = 0;
		readlen = bd->len;
	} else {
		/* Full page content should be read */
		scanlen = mtd->writesize + mtd->oobsize;
		readlen = len * mtd->writesize;
	}

	if (chip == -1) {
		/* Note that numblocks is 2 * (real numblocks) here, see i+=2
		 * below as it makes shifting and masking less painful */
		numblocks = mtd->size >> (this->bbt_erase_shift - 1);
		startblock = 0;
		from = 0;
	} else {
		if (chip >= this->numchips) {
			printk(KERN_WARNING "create_bbt(): chipnr (%d) > available chips (%d)\n",
			       chip + 1, this->numchips);
			return -EINVAL;
		}
		numblocks = this->chipsize >> (this->bbt_erase_shift - 1);
		startblock = chip * numblocks;
		numblocks += startblock;
		from = (loff_t)startblock << (this->bbt_erase_shift - 1);
	}
    
	for (i = startblock; i < numblocks;) {
		int ret;

		if (bd->options & NAND_BBT_SCANALLPAGES)
			ret = scan_block_full(mtd, bd, from, buf, readlen,
					      scanlen, len);
		else if(bd->options & NAND_BBT_SCANASSIGNEDPAGES)
			ret = scan_block_specific(mtd, bd, from, buf, len);
		else
			ret = scan_block_fast(mtd, bd, from, buf, len);
        
		if (ret < 0)
			return ret;

		if (ret) {
			this->bbt[i >> 3] |= 0x03 << (i & 0x6);
			MTDDEBUG (MTD_DEBUG_LEVEL0,
				  "Bad eraseblock %d at 0x%012llx\n",
				  i >> 1, (unsigned long long)from);
			mtd->ecc_stats.badblocks++;
		}

		i += 2;
		from += (1 << this->bbt_erase_shift);
	}
	return 0;
}

/**
 * search_bbt - [GENERIC] scan the device for a specific bad block table
 * @mtd:	MTD device structure
 * @buf:	temporary buffer
 * @td:		descriptor for the bad block table
 *
 * Read the bad block table by searching for a given ident pattern.
 * Search is preformed either from the beginning up or from the end of
 * the device downwards. The search starts always at the start of a
 * block.
 * If the option NAND_BBT_PERCHIP is given, each chip is searched
 * for a bbt, which contains the bad block information of this chip.
 * This is necessary to provide support for certain DOC devices.
 *
 * The bbt ident pattern resides in the oob area of the first page
 * in a block.
 */
static int search_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td)
{
	struct nand_chip *this = mtd->priv;
	int i, chips;
	int bits, startblock, block, dir;
	int scanlen = mtd->writesize + mtd->oobsize;
	int bbtblocks;
	int blocktopage = this->bbt_erase_shift - this->page_shift;

	/* Search direction top -> down ? */
	if (td->options & NAND_BBT_LASTBLOCK) {
		startblock = (mtd->size >> this->bbt_erase_shift) - 1;
		dir = -1;
	} else {
		startblock = 0;
		dir = 1;
	}

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chips = this->numchips;
		bbtblocks = this->chipsize >> this->bbt_erase_shift;
		startblock &= bbtblocks - 1;
	} else {
		chips = 1;
		bbtblocks = mtd->size >> this->bbt_erase_shift;
	}

	/* Number of bits for each erase block in the bbt */
	bits = td->options & NAND_BBT_NRBITS_MSK;

	for (i = 0; i < chips; i++) {
		/* Reset version information */
		td->version[i] = 0;
		td->pages[i][0] = -1;
		/* Scan the maximum number of blocks */
		for (block = 0; block < td->maxblocks; block++) {

			int actblock = startblock + dir * block;
			loff_t offs = (loff_t)actblock << this->bbt_erase_shift;

			/* Read first page */
			scan_read_raw(mtd, buf, offs, mtd->writesize);
			if (!check_pattern(buf, scanlen, mtd->writesize, td)) {
				td->pages[i][0] = actblock << blocktopage;
				if (td->options & NAND_BBT_VERSION) {
					td->version[i] = buf[mtd->writesize + td->veroffs];
				}
				break;
			}
		}
		startblock += this->chipsize >> this->bbt_erase_shift;
	}
	/* Check, if we found a bbt for each requested chip */
	for (i = 0; i < chips; i++) {
		if (td->pages[i][0] == -1)
			printk(KERN_WARNING "Bad block table not found for chip %d\n", i);
		else
			printk(KERN_DEBUG "Bad block table found at page %d, version 0x%02X\n", td->pages[i][0],
			       td->version[i]);
	}
	return 0;
}

/**
 * search_read_bbts - [GENERIC] scan the device for bad block table(s)
 * @mtd:	MTD device structure
 * @buf:	temporary buffer
 * @td:		descriptor for the bad block table
 * @md:		descriptor for the bad block table mirror
 *
 * Search and read the bad block table(s)
*/
static int search_read_bbts(struct mtd_info *mtd, uint8_t * buf, struct nand_bbt_descr *td, struct nand_bbt_descr *md)
{
	/* Search the primary table */
	search_bbt(mtd, buf, td);

	/* Search the mirror table */
	if (md)
		search_bbt(mtd, buf, md);

	/* Force result check */
	return 1;
}

/**
 * write_bbt - [GENERIC] (Re)write the bad block table
 *
 * @mtd:	MTD device structure
 * @buf:	temporary buffer
 * @td:		descriptor for the bad block table
 * @md:		descriptor for the bad block table mirror
 * @chipsel:	selector for a specific chip, -1 for all
 *
 * (Re)write the bad block table
 *
*/
static int write_bbt(struct mtd_info *mtd, uint8_t *buf,
		     struct nand_bbt_descr *td, struct nand_bbt_descr *md,
		     int chipsel)
{
	struct nand_chip *this = mtd->priv;
	struct erase_info einfo;
	int i, j, res, chip = 0;
	int bits, startblock, dir, page, offs, numblocks, sft, sftmsk, bbtpage, k;
	int nrchips, bbtoffs, pageoffs, ooboffs;
	uint8_t msk[4];
	uint8_t rcode = td->reserved_block_code;
	size_t retlen, len = 0;
	loff_t to, lsbpage;
	struct mtd_oob_ops ops;
    int retries=0;    
    uint8_t *pagebuf;

	ops.ooblen = mtd->oobsize;
	ops.ooboffs = 0;
	ops.datbuf = NULL;
	ops.mode = MTD_OOB_PLACE;

	if (!rcode)
		rcode = 0xff;
	/* Write bad block table per chip rather than per device ? */
	if (td->options & NAND_BBT_PERCHIP) {
		numblocks = (int)(this->chipsize >> this->bbt_erase_shift);
		/* Full device write or specific chip ? */
		if (chipsel == -1) {
			nrchips = this->numchips;
		} else {
			nrchips = chipsel + 1;
			chip = chipsel;
		}
	} else {
		numblocks = (int)(mtd->size >> this->bbt_erase_shift);
		nrchips = 1;
	}

	/* Loop through the chips */
	for (; chip < nrchips; chip++) {

		/* There was already a version of the table, reuse the page
		 * This applies for absolute placement too, as we have the
		 * page nr. in td->pages.
		 */
/*		if (td->pages[chip] != -1) {
			page = td->pages[chip];
			goto write;
		}*/

		/* Automatic placement of the bad block table */
		/* Search direction top -> down ? */
		if (td->options & NAND_BBT_LASTBLOCK) {
			startblock = numblocks * (chip + 1) - 1;
			dir = -1;
		} else {
			startblock = chip * numblocks;
			dir = 1;
		}

		for (i = 0; i < td->maxblocks; i++) {
			int block = startblock + dir * i;
                    int blockofs = block << this->bbt_erase_shift;
			/* Check, if the block is bad */
			switch ((this->bbt[block >> 2] >>
				 (2 * (block & 0x03))) & 0x03) {
			case 0x01:
			case 0x03:
				continue;
			}
                    if (this->block_bad(mtd, blockofs, 0))
                        continue;            
			page = block <<
				(this->bbt_erase_shift - this->page_shift);
			/* Check, if the block is used by the mirror table */
			if (!md || md->pages[chip][0] != page)
				goto write;
		}
		printk(KERN_ERR "No space left to write bad block table\n");
		return nand_switchto_mem_bbt(mtd);
	write:

		/* Set up shift count and masks for the flash table */
		bits = td->options & NAND_BBT_NRBITS_MSK;
		msk[2] = ~rcode;
		switch (bits) {
		case 1: sft = 3; sftmsk = 0x07; msk[0] = 0x00; msk[1] = 0x01;
			msk[3] = 0x01;
			break;
		case 2: sft = 2; sftmsk = 0x06; msk[0] = 0x00; msk[1] = 0x01;
			msk[3] = 0x03;
			break;
		case 4: sft = 1; sftmsk = 0x04; msk[0] = 0x00; msk[1] = 0x0C;
			msk[3] = 0x0f;
			break;
		case 8: sft = 0; sftmsk = 0x00; msk[0] = 0x00; msk[1] = 0x0F;
			msk[3] = 0xff;
			break;
		default: return -EINVAL;
		}

		bbtoffs = chip * (numblocks >> 2);

		to = ((loff_t) page) << this->page_shift;

		/* Must we save the block contents ? */
		if (td->options & NAND_BBT_SAVECONTENT) {
			/* Make it block aligned */
			to &= ~((loff_t) ((1 << this->bbt_erase_shift) - 1));
			len = 1 << this->bbt_erase_shift;
			res = mtd->read(mtd, to, len, &retlen, buf);
			if (res < 0) {
				if (retlen != len) {
					printk(KERN_INFO "nand_bbt: Error "
					       "reading block for writing "
					       "the bad block table\n");
					return res;
				}
				printk(KERN_WARNING "nand_bbt: ECC error "
				       "while reading block for writing "
				       "bad block table\n");
			}
			/* Read oob data */
			ops.ooblen = (len >> this->page_shift) * mtd->oobsize;
			ops.oobbuf = &buf[len];
			res = mtd->read_oob(mtd, to + mtd->writesize, &ops);
			if (res < 0 || ops.oobretlen != ops.ooblen)
				goto outerr;

			/* Calc the byte offset in the buffer */
			pageoffs = page - (int)(to >> this->page_shift);
			offs = pageoffs << this->page_shift;
			/* Preset the bbt area with 0xff */
			memset(&buf[offs], 0xff, (size_t) (numblocks >> sft));
			ooboffs = len + (pageoffs * mtd->oobsize);

		} else {
			/* Calc length */
			len = (size_t) (numblocks >> sft);
			/* Make it page aligned ! */
			len = (len + (mtd->writesize - 1)) &
				~(mtd->writesize - 1);
			/* Preset the buffer with 0xff */
			memset(buf, 0xff, len +
			       (len >> this->page_shift)* mtd->oobsize);
			offs = 0;
                    bbtpage = len / mtd->writesize;
                    for(k=0; k<bbtpage; k++){
                        ooboffs = mtd->writesize + (mtd->writesize + mtd->oobsize) * k;
                        /* Pattern is located in oob area of first page */
                        memcpy(&buf[ooboffs + td->offs], td->pattern, td->len);                       
                    }
		}

		if (td->options & NAND_BBT_VERSION){
                    bbtpage = len / mtd->writesize;
                    for(k=0; k<bbtpage; k++){
                        ooboffs = mtd->writesize + (mtd->writesize + mtd->oobsize) * k;
                        buf[ooboffs + td->veroffs] = td->version[chip];                       
                    }                                        
		}

		/* walk through the memory table */
		for (i = 0; i < numblocks;) {
			uint8_t dat;
			dat = this->bbt[bbtoffs + (i >> 2)];
			for (j = 0; j < 4; j++, i++) {
				int sftcnt = (i << (3 - sft)) & sftmsk;
				/* Do not store the reserved bbt blocks ! */
				buf[offs + (i >> sft)] &=
					~(msk[dat & 0x03] << sftcnt);
				dat >>= 2;
			}
		}

retry:
		memset(&einfo, 0, sizeof(einfo));
		einfo.mtd = mtd;
		einfo.addr = to;
		einfo.len = 1 << this->bbt_erase_shift;
		res = nand_erase_nand(mtd, &einfo, 1);
        
            if ((res<0) && (retries<NAND_RETRIES)){
                    retries++;
                    goto retry;
             }
        
            /*erase error, mark the bbt block bad. so it should rescan the device and update the bbt */                   
            if(retries >= NAND_RETRIES)
            {
                if(NAND_STATUS_HWFAIL == einfo.state){
                    printk("Erase fail, mark the block bad!\n");
                    this->block_markbad(mtd, (loff_t)to);
                    printk("nand_erase: "
                        "mark block 0x%llx bad\n", to);
                }    
                goto outerr;
            }

            // paired page effect and loop bbt write 
            bbtpage = len / mtd->writesize;
            for(k=0; k<bbtpage; k++){
                pagebuf = buf + (mtd->writesize + mtd->oobsize) * k;
#ifdef CONFIG_MTD_UBI_BACKUP_LSB                
                lsbpage = to + ga_tPairedPageMap[k].u16_LSB * mtd->writesize;
#else
                lsbpage = to + k * mtd->writesize;
#endif
                res = scan_write_bbt(mtd, lsbpage, mtd->writesize, pagebuf, &pagebuf[mtd->writesize]);
        
                if ((res<0) && (retries<NAND_RETRIES)){
                        retries++;
                        goto retry;
                 }
            
                if(retries >= NAND_RETRIES){
                        printk("Write fail, mark the block bad!\n");
                        this->block_markbad(mtd, (loff_t)to);                    
                        goto outerr;
                } 

                printk(KERN_DEBUG "Bad block table written to 0x%012llx, "
        		       "version 0x%02X\n", (unsigned long long)to,
        		       td->version[chip]);

                /* Mark it as used */
                td->pages[chip][k] = (int) lsbpage >> this->page_shift;
                
            }             
	}
	return 0;

 outerr:
	printk(KERN_WARNING
	       "nand_bbt: Error while writing bad block table %d\n", res);
	return res;
}

/**
 * nand_memory_bbt - [GENERIC] create a memory based bad block table
 * @mtd:	MTD device structure
 * @bd:		descriptor for the good/bad block search pattern
 *
 * The function creates a memory based bbt by scanning the device
 * for manufacturer / software marked good / bad blocks
*/
static inline int nand_memory_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
	struct nand_chip *this = mtd->priv;

	bd->options &= ~NAND_BBT_SCANEMPTY;
	return create_bbt(mtd, this->buffers->databuf, bd, -1);
}

/**
 * check_create - [GENERIC] create and write bbt(s) if necessary
 * @mtd:	MTD device structure
 * @buf:	temporary buffer
 * @bd:		descriptor for the good/bad block search pattern
 *
 * The function checks the results of the previous call to read_bbt
 * and creates / updates the bbt(s) if necessary
 * Creation is necessary if no bbt was found for the chip/device
 * Update is necessary if one of the tables is missing or the
 * version nr. of one table is less than the other
*/
static int check_create(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd)
{
	int i, chips, writeops, chipsel, res;
	struct nand_chip *this = mtd->priv;
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;
	struct nand_bbt_descr *rd, *rd2;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP)
		chips = this->numchips;
	else
		chips = 1;

	for (i = 0; i < chips; i++) {
		writeops = 0;
		rd = NULL;
		rd2 = NULL;
		/* Per chip or per device ? */
		chipsel = (td->options & NAND_BBT_PERCHIP) ? i : -1;
		/* Mirrored table avilable ? */
		if (md) {
			if (td->pages[i][0] == -1 && md->pages[i][0] == -1) {
				writeops = 0x03;
				goto create;
			}

			if (td->pages[i][0] == -1) {
				rd = md;
				td->version[i] = md->version[i];
				writeops = 1;
				goto writecheck;
			}

			if (md->pages[i][0] == -1) {
				rd = td;
				md->version[i] = td->version[i];
				writeops = 2;
				goto writecheck;
			}

			if (td->version[i] == md->version[i]) {
				rd = td;
				if (!(td->options & NAND_BBT_VERSION))
					rd2 = md;
				goto writecheck;
			}

			if (((int8_t) (td->version[i] - md->version[i])) > 0) {
				rd = td;
				md->version[i] = td->version[i];
                        check_bbt_consistency(mtd, td, md, 0);                                                        
				writeops = 2;
			} else {
				rd = md;
				td->version[i] = md->version[i];
				writeops = 1;
			}

			goto writecheck;

		} else {
			if (td->pages[i][0] == -1) {
				writeops = 0x01;
				goto create;
			}
			rd = td;
			goto writecheck;
		}
	create:
		/* Create the bad block table by scanning the device ? */
		if (!(td->options & NAND_BBT_CREATE))
			continue;
        
             /* Check if had enough space left to creat bbt*/       
             res = check_space_bbt(mtd, td, md, chipsel);

             if(!res)
                    continue;
             
		/* Create the table in memory by scanning the chip(s) */
		create_bbt(mtd, buf, bd, chipsel);

		td->version[i] = 1;
		if (md)
			md->version[i] = 1;
	writecheck:
		/* read back first ? */
		if (rd)
			read_abs_bbt(mtd, buf, rd, chipsel);
		/* If they weren't versioned, read both. */
		if (rd2)
			read_abs_bbt(mtd, buf, rd2, chipsel);

		/* Write the bad block table to the device ? */
		if ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {
			res = write_bbt(mtd, buf, td, md, chipsel);
			if (res < 0)
				return res;
		}

		/* Write the mirror bad block table to the device ? */
		if ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {
			res = write_bbt(mtd, buf, md, td, chipsel);
			if (res < 0)
				return res;
		}
	}
	return 0;
}

/**
 * mark_bbt_regions - [GENERIC] mark the bad block table regions
 * @mtd:	MTD device structure
 * @td:		bad block table descriptor
 *
 * The bad block table regions are marked as "bad" to prevent
 * accidental erasures / writes. The regions are identified by
 * the mark 0x02.
*/
static void mark_bbt_region(struct mtd_info *mtd, struct nand_bbt_descr *td)
{
	struct nand_chip *this = mtd->priv;
	int i, j, chips, block, nrblocks, update;
	uint8_t oldval, newval;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chips = this->numchips;
		nrblocks = (int)(this->chipsize >> this->bbt_erase_shift);
	} else {
		chips = 1;
		nrblocks = (int)(mtd->size >> this->bbt_erase_shift);
	}

	for (i = 0; i < chips; i++) {
		if ((td->options & NAND_BBT_ABSPAGE) ||
		    !(td->options & NAND_BBT_WRITE)) {
			if (td->pages[i][0] == -1)
				continue;
			block = td->pages[i][0] >> (this->bbt_erase_shift - this->page_shift);
			block <<= 1;
			oldval = this->bbt[(block >> 3)];
			newval = oldval | (0x2 << (block & 0x06));
			this->bbt[(block >> 3)] = newval;
			if ((oldval != newval) && td->reserved_block_code)
				nand_update_bbt(mtd, (loff_t)block <<
					(this->bbt_erase_shift - 1));
			continue;
		}
		update = 0;
		if (td->options & NAND_BBT_LASTBLOCK)
			block = ((i + 1) * nrblocks) - td->maxblocks;
		else
			block = i * nrblocks;
		block <<= 1;
		for (j = 0; j < td->maxblocks; j++) {
			oldval = this->bbt[(block >> 3)];
			newval = oldval | (0x2 << (block & 0x06));
			this->bbt[(block >> 3)] = newval;
			if (oldval != newval)
				update = 1;
			block += 2;
		}
		/* If we want reserved blocks to be recorded to flash, and some
		   new ones have been marked, then we need to update the stored
		   bbts.  This should only happen once. */
		if (update && td->reserved_block_code)
			nand_update_bbt(mtd, (loff_t)(block - 2) <<
				(this->bbt_erase_shift - 1));
	}
}

/**
 * nand_scan_bbt - [NAND Interface] scan, find, read and maybe create bad block table(s)
 * @mtd:	MTD device structure
 * @bd:		descriptor for the good/bad block search pattern
 *
 * The function checks, if a bad block table(s) is/are already
 * available. If not it scans the device for manufacturer
 * marked good / bad blocks and writes the bad block table(s) to
 * the selected place.
 *
 * The bad block table memory is allocated here. It must be freed
 * by calling the nand_free_bbt function.
 *
*/
#if (ENABLE_MODULE_NAND_FLASH == 1)
extern int Disable_Err_log; 
#endif
int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
	struct nand_chip *this = mtd->priv;
	int len, res = 0, i;
	uint8_t *buf;
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;
    #if (ENABLE_MODULE_NAND_FLASH == 1)
    int cisret, ciscount = 0;
   	uint8_t *cisbuf;
	loff_t cisfrom=0;    
    #endif

	len = mtd->size >> (this->bbt_erase_shift + 2);
	/* Allocate memory (2bit per block) and clear the memory bad block table */
	this->bbt = kzalloc(len, GFP_KERNEL);
	if (!this->bbt) {
		printk(KERN_ERR "nand_scan_bbt: Out of memory\n");
		return -ENOMEM;
	}

	len = (1 << this->bbt_erase_shift);
	len += (len >> this->page_shift) * mtd->oobsize;

    #if (ENABLE_MODULE_NAND_FLASH == 1)
    //scan and mark cis block
    cisbuf = vmalloc(len);
    if (!cisbuf) {
            printk(KERN_ERR "nand_bbt: Out of memory\n");
            kfree(this->bbt);
            this->bbt = NULL;
            return -ENOMEM;
    }
	// disable hal ecc error log
	Disable_Err_log = 1;
    //reserved 10 blocks for cis
    for(i = 0; i < 20;){
            cisret = scan_read_hwecc(mtd, cisbuf, cisfrom, mtd->writesize);
            
            //if meet ecc fail err, mark it as bad as bbt block           
            if(-EBADMSG == cisret){
                this->bbt[i >> 3] |= 0x02 << (i & 0x6);
                ciscount++;
            }
            if(ciscount >= 2)
                break;
            i += 2;
            cisfrom += (1 << this->bbt_erase_shift);                    
    }
	// enable hal ecc error log
	Disable_Err_log = 0;

    vfree(cisbuf);
    #elif (ENABLE_MODULE_SPI_NAND_FLASH == 1)
    for(i = 0; i < 20; i += 2)
        this->bbt[i >> 3] |= 0x02 << (i & 0x6);

	if(gtSpiNandDrv.tSpinandInfo.au8_ID[0] == 0xC8) // GD : last 4 blocks are reserved for security.
	{
		for(i = ((mtd->size>>this->phys_erase_shift)-1)*2; i >= ((mtd->size>>this->phys_erase_shift)-4)*2; i -= 2)
			this->bbt[i >> 3] |= 0x03 << (i & 0x6);
	}
    #endif
   
	/* If no primary table decriptor is given, scan the device
	 * to build a memory based bad block table
	 */
	if (!td) {
		if ((res = nand_memory_bbt(mtd, bd))) {
			printk(KERN_ERR "nand_bbt: Can't scan flash and build the RAM-based BBT\n");
			kfree(this->bbt);
			this->bbt = NULL;
		}
		return res;
	}

	/* Allocate a temporary buffer for one eraseblock incl. oob */

	buf = vmalloc(len);
	if (!buf) {
		printk(KERN_ERR "nand_bbt: Out of memory\n");
		kfree(this->bbt);
		this->bbt = NULL;
		return -ENOMEM;
	}

	/* Is the bbt at a given page ? */
	if (td->options & NAND_BBT_ABSPAGE) {
		res = read_abs_bbts(mtd, buf, td, md);
	} else {
		/* Search the bad block table using a pattern in oob */
		res = search_read_bbts(mtd, buf, td, md);
	}

	if (res)
		res = check_create(mtd, buf, bd);

	/* Prevent the bbt regions from erasing / writing */
	mark_bbt_region(mtd, td);
	if (md)
		mark_bbt_region(mtd, md);

	vfree(buf);

	this->bbt_crc = crc32(BBT_CRC32_INIT, this->bbt, (mtd->size >> (this->bbt_erase_shift + 2)));

	return res;
}

/**
 * nand_update_bbt - [NAND Interface] update bad block table(s)
 * @mtd:	MTD device structure
 * @offs:	the offset of the newly marked block
 *
 * The function updates the bad block table(s)
*/
int nand_update_bbt(struct mtd_info *mtd, loff_t offs)
{
	struct nand_chip *this = mtd->priv;
	int len, res = 0, writeops = 0;
	int chip, chipsel;
	uint8_t *buf;
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;

	if (!this->bbt || !td)
		return -EINVAL;

	/* Allocate a temporary buffer for one eraseblock incl. oob */
	len = (1 << this->bbt_erase_shift);
	len += (len >> this->page_shift) * mtd->oobsize;
	buf = kmalloc(len, GFP_KERNEL);
	if (!buf) {
		printk(KERN_ERR "nand_update_bbt: Out of memory\n");
		return -ENOMEM;
	}

	writeops = md != NULL ? 0x03 : 0x01;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chip = (int)(offs >> this->chip_shift);
		chipsel = chip;
	} else {
		chip = 0;
		chipsel = -1;
	}

	td->version[chip]++;
	if (md)
		md->version[chip]++;

	/* Write the bad block table to the device ? */
	if ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {
		res = write_bbt(mtd, buf, td, md, chipsel);
		if (res < 0)
			goto out;
	}
	/* Write the mirror bad block table to the device ? */
	if ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {
		res = write_bbt(mtd, buf, md, td, chipsel);
	}

 out:
	kfree(buf);
	return res;
}

/**
 * nand_update_td - [NAND Interface] update bad block table td
 * @mtd:    MTD device structure
 * @offs:   the offset of the newly marked block
 *
 * The function updates the bad block table(s)
*/
int nand_update_td(struct mtd_info *mtd, loff_t offs)
{
        struct nand_chip *chippr = mtd->priv;
        int len, res = 0;
        int chip, chipsel;
        uint8_t *buf;
        struct nand_bbt_descr *td = chippr->bbt_td;
        struct nand_bbt_descr *md = chippr->bbt_md;

        if ((!chippr->bbt) || (!td))
            return -EINVAL;

        /* Allocate a temporary buffer for one eraseblock incl. oob */
        len = (1 << chippr->bbt_erase_shift);
        len += (len >> chippr->page_shift) * mtd->oobsize;
        buf = kmalloc(len, GFP_KERNEL);
        if (!buf) {
            printk(KERN_ERR "nand_update_td: Out of memory\n");
            return -ENOMEM;
        }

        /* Do we have a bbt per chip ? */
        if ((td->options) & NAND_BBT_PERCHIP) {
                chip = (int)(offs >> chippr->chip_shift);
                chipsel = chip;
        } else {
                chip = 0;
                chipsel = -1;
        }

        td->version[chip]++;

        /* Write the bad block table to the device ? */
        if (td->options & NAND_BBT_WRITE) {
                res = write_bbt(mtd, buf, td, md, chipsel);
        }


        kfree(buf);
        return res;
}

/**
 * nand_update_md - [NAND Interface] update bad block table md
 * @mtd:    MTD device structure
 * @offs:   the offset of the newly marked block
 *
 * The function updates the bad block table(s)
*/
int nand_update_md(struct mtd_info *mtd, loff_t offs)
{
        struct nand_chip *chippr = mtd->priv;
        int len, res = 0;
        int chip, chipsel;
        uint8_t *buf;
        struct nand_bbt_descr *td = chippr->bbt_td;
        struct nand_bbt_descr *md = chippr->bbt_md;

        if ((!chippr->bbt) || (!td))
            return -EINVAL;

        /* Allocate a temporary buffer for one eraseblock incl. oob */
        len = (1 << chippr->bbt_erase_shift);
        len += (len >> chippr->page_shift) * mtd->oobsize;
        buf = kmalloc(len, GFP_KERNEL);
        if (!buf) {
                printk(KERN_ERR "nand_update_md: Out of memory\n");
                return -ENOMEM;
        }

        /* Do we have a bbt per chip ? */
        if ((td->options) & NAND_BBT_PERCHIP) {
                chip = (int)(offs >> chippr->chip_shift);
                chipsel = chip;
        } else {
                chip = 0;
                chipsel = -1;
        }

        if (md)
                md->version[chip]++;

        /* Write the mirror bad block table to the device ? */
        if (md && (md->options & NAND_BBT_WRITE)) {
             res = write_bbt(mtd, buf, md, td, chipsel);
        }

        kfree(buf);
        return res;
}

/* Define some generic bad / good block scan pattern which are used
 * while scanning a device for factory marked good / bad blocks. */
static uint8_t scan_ff_pattern[] = { 0xff, 0xff };

static struct nand_bbt_descr smallpage_memorybased = {
	.options = NAND_BBT_SCAN2NDPAGE,
	.offs = 5,
	.len = 1,
	.pattern = scan_ff_pattern
};

static struct nand_bbt_descr largepage_memorybased = {
	.options = 0,
	.offs = 0,
	.len = 2,
	.pattern = scan_ff_pattern
};

static struct nand_bbt_descr smallpage_flashbased = {
	.options = NAND_BBT_SCAN2NDPAGE,
	.offs = 5,
	.len = 1,
	.pattern = scan_ff_pattern
};

static struct nand_bbt_descr largepage_flashbased = {
	.options = NAND_BBT_SCAN2NDPAGE,
	.offs = 0,
	.len = 2,
	.pattern = scan_ff_pattern
};

static uint8_t scan_agand_pattern[] = { 0x1C, 0x71, 0xC7, 0x1C, 0x71, 0xC7 };

static struct nand_bbt_descr agand_flashbased = {
	.options = NAND_BBT_SCANEMPTY | NAND_BBT_SCANALLPAGES,
	.offs = 0x20,
	.len = 6,
	.pattern = scan_agand_pattern
};

/* Generic flash bbt decriptors
*/
static uint8_t bbt_pattern[] = {'B', 'b', 't', '0' };
static uint8_t mirror_pattern[] = {'1', 't', 'b', 'B' };

static struct nand_bbt_descr bbt_main_descr = {
	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
	.offs =	1,
	.len = 3,
	.veroffs = 4,
	.maxblocks = NAND_BBT_BLOCK_NUM,
	.pattern = bbt_pattern
};

static struct nand_bbt_descr bbt_mirror_descr = {
	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
	.offs =	1,
	.len = 3,
	.veroffs = 4,
	.maxblocks = NAND_BBT_BLOCK_NUM,
	.pattern = mirror_pattern
};

/**
 * nand_default_bbt - [NAND Interface] Select a default bad block table for the device
 * @mtd:	MTD device structure
 *
 * This function selects the default bad block table
 * support for the device and calls the nand_scan_bbt function
 *
*/
int nand_default_bbt(struct mtd_info *mtd)
{
	struct nand_chip *this = mtd->priv;

	/* Default for AG-AND. We must use a flash based
	 * bad block table as the devices have factory marked
	 * _good_ blocks. Erasing those blocks leads to loss
	 * of the good / bad information, so we _must_ store
	 * this information in a good / bad table during
	 * startup
	 */
#ifdef CONFIG_MTD_NAND_BBT
        this->options |= NAND_USE_FLASH_BBT;
#else
        this->options &= ~NAND_USE_FLASH_BBT;
#endif 
    
	if (this->options & NAND_IS_AND) {
		/* Use the default pattern descriptors */
		if (!this->bbt_td) {
			this->bbt_td = &bbt_main_descr;
			this->bbt_md = &bbt_mirror_descr;
		}
		this->bbt_td->maxblocks = this->bbt_md->maxblocks 
			= mtd->bbt_block_num;

		this->options |= NAND_USE_FLASH_BBT;
		return nand_scan_bbt(mtd, &agand_flashbased);
	}

	/* Is a flash based bad block table requested ? */
	if (this->options & NAND_USE_FLASH_BBT) {
		/* Use the default pattern descriptors */
		if (!this->bbt_td) {
			this->bbt_td = &bbt_main_descr;
			this->bbt_md = &bbt_mirror_descr;
		}
		this->bbt_td->maxblocks = this->bbt_md->maxblocks 
			= mtd->bbt_block_num;

		if (!this->badblock_pattern) {
			this->badblock_pattern = (mtd->writesize > 512) ? &largepage_flashbased : &smallpage_flashbased;
		}
	} else {
		this->bbt_td = NULL;
		this->bbt_md = NULL;
		if (!this->badblock_pattern) {
			this->badblock_pattern = (mtd->writesize > 512) ?
			    &largepage_memorybased : &smallpage_memorybased;
		}
	}
	return nand_scan_bbt(mtd, this->badblock_pattern);
}

/**
 * nand_isbad_bbt - [NAND Interface] Check if a block is bad
 * @mtd:	MTD device structure
 * @offs:	offset in the device
 * @allowbbt:	allow access to bad block table region
 *
*/
int nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)
{
	struct nand_chip *this = mtd->priv;
	int block;
	uint8_t res;

	/* Get block number * 2 */
	block = (int)(offs >> (this->bbt_erase_shift - 1));
	res = (this->bbt[block >> 3] >> (block & 0x06)) & 0x03;

	MTDDEBUG (MTD_DEBUG_LEVEL2, "nand_isbad_bbt(): bbt info for offs 0x%08x: "
	          "(block %d) 0x%02x\n", (unsigned int)offs, res, block >> 1);

	switch ((int)res) {
	case 0x00:
		return 0;
	case 0x01:
		return 1;
	case 0x02:
		return allowbbt ? 0 : 2;
	}
	return 1;
}

/**
 * nand_switchto_mem_bbt - switch flash base bbt to mem base bbt mode
 * @mtd:    MTD device structure
 *
*/
int nand_switchto_mem_bbt(struct mtd_info *mtd)
{
        struct nand_chip *chip = mtd->priv;
    
        if(chip->options & NAND_USE_FLASH_BBT){
            printk("Switch to memory based bbt!\n");
            chip->options &= ~NAND_USE_FLASH_BBT;
            chip->bbt_td = NULL;
            chip->bbt_md = NULL;
            if (!chip->badblock_pattern) {
                chip->badblock_pattern = (mtd->writesize > 512) ?
                    &largepage_memorybased : &smallpage_memorybased;
                }
            return nand_scan_bbt(mtd, chip->badblock_pattern);
       }
       return 0;
}

