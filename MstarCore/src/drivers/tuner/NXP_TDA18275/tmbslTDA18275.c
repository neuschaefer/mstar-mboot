/*
  Copyright (C) 2012 NXP B.V., All Rights Reserved.
  This source code and any compilation or derivative thereof is the proprietary
  information of NXP B.V. and is confidential in nature. Under no circumstances
  is this software to be  exposed to or placed under an Open Source License of
  any type without the expressed written permission of NXP B.V.
 *
 * \file          tmbslTDA18275.c
 *
 *                %version:%
 *
 * \date          %modify_time%
 *
 * \author        Michael VANNIER
 *
 *
 * \brief         Describe briefly the purpose of this file.
 *
 * REFERENCE DOCUMENTS :
 *                TDA18275_Driver_User_Guide.pdf
 *
 *
 * \section info Change Information
 *
*/

/*============================================================================*/
/* Standard include files:                                                    */
/*============================================================================*/
#include "tmNxTypes.h"
#include "tmCompId.h"
#include "tmFrontEnd.h"
#include "tmbslFrontEndTypes.h"

/*============================================================================*/
/* Project include files:                                                     */
/*============================================================================*/
#include "tmbslTDA18275.h"

#include "tmbslTDA18275_RegDef.h"
#include "tmbslTDA18275_Local.h"
#include "tmbslTDA18275_Instance.h"
#include "tmbslTDA18275_InstanceCustom.h"


/*============================================================================*/
/* Static internal functions:                                                 */
/*============================================================================*/
static tmErrorCode_t iTDA18275_AdaptICP(pTDA18275Object_t pObj, UInt8 uadc_vtune, UInt8 uVCO_select );
static tmErrorCode_t iTDA18275_VCOselection(pTDA18275Object_t pObj);
static tmErrorCode_t iTDA18275_ReadThermo (pTDA18275Object_t pObj, UInt8* puThermo);
static tmErrorCode_t iTDA18275_ReadallFVCO(pTDA18275Object_t   pObj);
static tmErrorCode_t iTDA18275_ReadFVCO(pTDA18275Object_t   pObj, UInt8 VCOnum, UInt8 VCOfreq);
static tmErrorCode_t iTDA18275_CalculateNIntKInt( pTDA18275Object_t pObj, UInt32* NInt, UInt32* KInt);

/*============================================================================*/
/* Static variables:                                                          */
/*============================================================================*/

typedef struct _TDA18275_Code_Lu_def_
{
    UInt16  gnd;
    UInt16  feed;
} TDA18275_Code_Lu_def;

/* Table that maps LO vs Prescaler & PostDiv values */
static TDA18275_Code_Lu_def  Code_Lu[131] =
{
{0, 0},
{0, 1},
{1, 0},
{1, 1},
{2, 2},
{2, 4},
{4, 4},
{3, 3},
{5, 5},
{6, 6},
{6, 7},
{7, 7},
{11, 11},
{13, 13},
{14, 14},
{14, 15},
{15, 15},
{15, 23},
{23, 27},
{27, 29},
{29, 30},
{31, 31},
{31, 47},
{47, 55},
{55, 59},
{62, 62},
{63, 63},
{63, 95},
{95, 111},
{111, 119},
{125, 125},
{127, 127},
{127, 191},
{191, 223},
{223, 239},
{251, 251},
{255, 255},
{380, 380},
{381, 379},
{438, 442},
{444, 444},
{443, 443},
{446, 446},
{486, 490},
{490, 492},
{491, 493},
{494, 504},
{502, 502},
{506, 508},
{507, 507},
{510, 510},
{511, 511},
{761, 761},
{763, 759},
{877, 885},
{889, 889},
{887, 887},
{893, 893},
{973, 981},
{981, 985},
{983, 987},
{989, 1009},
{1005, 1005},
{1013, 1017},
{1015, 1015},
{1021, 1021},
{1023, 1023},
{1523, 1523},
{1527, 1519},
{1755, 1771},
{1779, 1779},
{1775, 1775},
{1787, 1787},
{1947, 1963},
{1963, 1971},
{1967, 1975},
{1979, 2019},
{2011, 2011},
{2027, 2035},
{2031, 2031},
{2043, 2043},
{2047, 2047},
{3047, 3047},
{3055, 3039},
{3511, 3543},
{3559, 3559},
{3551, 3551},
{3575, 3575},
{3895, 3927},
{3927, 3943},
{3935, 3951},
{3959, 4039},
{4023, 4023},
{4055, 4071},
{4063, 4063},
{4087, 4087},
{4095, 4095},
{0, 2},
{0, 3},
{1, 2},
{1, 3},
{2, 3},
{2, 5},
{2, 6},
{3, 5},
{3, 7},
{5, 11},
{5, 7},
{7, 11},
{13, 23},
{13, 15},
{15, 27},
{23, 29},
{27, 31},
{27, 30},
{29, 31},
{6, 11},
{7, 14},
{7, 15},
{14, 23},
{14, 27},
{15, 29},
{29, 47},
{30, 31},
{31, 55},
{47, 59},
{55, 62},
{62, 63},
{63, 111},
{95, 119},
{111, 125}
};

typedef struct _TDA18275_FilterRFDef_
{
    UInt32 LO_upto;
    UInt8 Code_Lu_index[32];
} TDA18275_FilterRFDef;

static TDA18275_FilterRFDef TDA18275_FilterRF[154] =
{
{ 48000 , {69, 70, 69, 70, 72, 73, 72, 74, 75, 76, 76, 77, 78, 79, 79, 80, 81, 81, 82, 82, 82, 83, 83, 84, 84, 84, 85, 85, 86, 86, 87, 87} },
{ 48922 , {68, 69, 68, 70, 70, 70, 71, 73, 74, 75, 74, 76, 77, 78, 78, 79, 79, 80, 81, 81, 82, 81, 82, 83, 83, 84, 84, 84, 85, 85, 86, 86} },
{ 49861 , {68, 68, 68, 68, 69, 70, 70, 71, 73, 73, 74, 75, 76, 76, 77, 78, 78, 79, 80, 80, 81, 82, 82, 82, 82, 83, 83, 83, 84, 85, 85, 85} },
{ 50818 , {67, 67, 67, 67, 69, 69, 69, 71, 72, 73, 73, 74, 75, 76, 76, 77, 77, 78, 79, 79, 80, 80, 81, 82, 82, 82, 82, 83, 83, 84, 84, 84} },
{ 51794 , {66, 67, 67, 67, 68, 69, 68, 70, 71, 72, 73, 73, 74, 74, 75, 76, 76, 77, 78, 78, 79, 79, 80, 81, 81, 82, 82, 82, 82, 83, 83, 83} },
{ 52789 , {65, 65, 66, 67, 66, 68, 69, 69, 70, 69, 71, 72, 73, 73, 74, 75, 75, 76, 76, 77, 78, 78, 79, 79, 80, 81, 81, 82, 82, 82, 82, 82} },
{ 53802 , {64, 64, 65, 66, 67, 67, 68, 67, 69, 70, 70, 71, 72, 72, 73, 74, 74, 75, 76, 76, 77, 77, 78, 79, 79, 80, 80, 81, 81, 81, 81, 81} },
{ 54835 , {63, 63, 64, 65, 66, 66, 67, 68, 68, 69, 69, 70, 71, 71, 72, 73, 73, 74, 74, 75, 76, 76, 77, 77, 78, 79, 79, 80, 80, 80, 80, 80} },
{ 55888 , {61, 62, 63, 64, 65, 65, 66, 67, 67, 68, 69, 69, 70, 70, 71, 71, 72, 73, 73, 74, 75, 75, 76, 76, 77, 78, 78, 79, 79, 79, 79, 79} },
{ 56961 , {61, 61, 62, 63, 64, 64, 65, 66, 67, 67, 68, 68, 69, 69, 70, 71, 71, 72, 73, 73, 74, 74, 75, 76, 76, 76, 77, 78, 78, 78, 78, 78} },
{ 58055 , {59, 60, 61, 62, 63, 63, 64, 65, 65, 66, 67, 67, 68, 68, 69, 70, 70, 71, 71, 72, 73, 73, 74, 74, 75, 76, 76, 76, 77, 77, 77, 77} },
{ 59170 , {58, 59, 60, 61, 61, 62, 63, 64, 64, 65, 66, 67, 67, 68, 68, 69, 69, 70, 70, 71, 71, 72, 73, 73, 74, 74, 75, 76, 76, 76, 76, 76} },
{ 60306 , {58, 58, 59, 60, 61, 61, 62, 63, 63, 64, 65, 65, 66, 67, 67, 68, 68, 69, 69, 70, 70, 71, 72, 72, 73, 73, 74, 74, 75, 75, 75, 75} },
{ 61464 , {56, 57, 58, 59, 59, 60, 61, 61, 62, 63, 64, 64, 65, 66, 66, 67, 68, 68, 69, 69, 70, 70, 70, 71, 72, 73, 73, 74, 74, 74, 74, 74} },
{ 62644 , {55, 56, 57, 58, 58, 59, 60, 61, 61, 62, 63, 63, 64, 65, 65, 66, 67, 67, 68, 68, 69, 69, 70, 70, 70, 71, 72, 73, 73, 73, 73, 73} },
{ 63847 , {55, 55, 56, 56, 57, 58, 59, 59, 60, 61, 61, 62, 63, 64, 64, 65, 66, 66, 67, 67, 68, 68, 69, 69, 70, 70, 70, 71, 72, 72, 72, 72} },
{ 65073 , {54, 54, 55, 56, 56, 57, 58, 59, 59, 60, 61, 61, 62, 63, 63, 64, 64, 65, 66, 66, 67, 67, 68, 68, 69, 69, 70, 70, 70, 71, 71, 71} },
{ 66322 , {53, 53, 54, 55, 55, 56, 57, 58, 58, 59, 59, 60, 61, 61, 62, 63, 63, 64, 65, 65, 66, 67, 67, 68, 68, 68, 69, 69, 70, 70, 70, 70} },
{ 67596 , {52, 53, 53, 54, 54, 55, 56, 56, 57, 58, 59, 59, 60, 61, 61, 62, 62, 63, 64, 64, 65, 65, 66, 67, 67, 68, 68, 68, 68, 69, 69, 69} },
{ 68894 , {51, 52, 52, 53, 54, 54, 55, 55, 56, 57, 58, 58, 59, 59, 60, 61, 61, 62, 63, 63, 64, 64, 65, 66, 66, 67, 67, 67, 68, 68, 68, 68} },
{ 70216 , {50, 51, 51, 52, 53, 53, 54, 55, 55, 56, 56, 57, 58, 58, 59, 60, 61, 61, 61, 62, 63, 63, 64, 64, 65, 66, 66, 67, 67, 67, 67, 67} },
{ 71565 , {49, 49, 50, 51, 52, 52, 53, 54, 54, 55, 55, 56, 57, 58, 58, 59, 59, 60, 61, 61, 62, 62, 63, 64, 64, 65, 65, 66, 66, 66, 66, 66} },
{ 72939 , {48, 48, 49, 50, 51, 52, 52, 53, 53, 54, 55, 55, 56, 56, 57, 58, 58, 59, 59, 60, 61, 61, 62, 62, 63, 64, 64, 65, 65, 65, 65, 65} },
{ 74339 , {47, 47, 48, 49, 50, 50, 51, 52, 52, 53, 54, 54, 55, 55, 56, 57, 57, 58, 58, 59, 60, 60, 61, 61, 62, 63, 63, 64, 64, 64, 64, 64} },
{ 75767 , {46, 46, 47, 48, 49, 49, 50, 51, 52, 52, 53, 53, 54, 54, 55, 56, 56, 57, 58, 58, 59, 59, 60, 61, 61, 61, 62, 63, 63, 63, 63, 63} },
{ 77221 , {45, 46, 46, 47, 48, 48, 49, 50, 51, 51, 52, 52, 53, 54, 54, 55, 55, 56, 56, 57, 58, 58, 59, 59, 60, 61, 61, 61, 62, 62, 62, 62} },
{ 78704 , {44, 44, 45, 46, 46, 47, 48, 49, 49, 50, 51, 52, 52, 53, 53, 54, 54, 55, 55, 56, 56, 57, 58, 58, 59, 59, 60, 61, 61, 61, 61, 61} },
{ 80215 , {43, 43, 44, 45, 46, 46, 47, 48, 48, 49, 50, 50, 51, 52, 52, 53, 53, 54, 55, 55, 56, 56, 57, 57, 58, 58, 59, 59, 60, 60, 60, 60} },
{ 81756 , {41, 42, 43, 44, 44, 45, 46, 47, 47, 48, 49, 49, 50, 51, 51, 52, 53, 53, 54, 54, 55, 55, 56, 56, 57, 58, 58, 59, 59, 59, 59, 59} },
{ 83325 , {41, 41, 42, 43, 44, 44, 45, 46, 46, 47, 48, 48, 49, 50, 50, 51, 52, 52, 53, 53, 54, 54, 55, 55, 56, 56, 57, 58, 58, 58, 58, 58} },
{ 84925 , {40, 40, 41, 42, 43, 43, 44, 45, 46, 46, 47, 47, 48, 49, 49, 50, 51, 51, 52, 52, 53, 53, 54, 54, 55, 55, 56, 56, 57, 57, 57, 57} },
{ 86556 , {39, 39, 40, 41, 41, 42, 43, 44, 44, 45, 46, 46, 47, 48, 48, 49, 49, 50, 51, 51, 52, 52, 53, 54, 54, 54, 55, 55, 56, 56, 56, 56} },
{ 88218 , {38, 39, 39, 40, 40, 41, 42, 43, 43, 44, 45, 45, 46, 46, 47, 48, 49, 49, 50, 50, 51, 52, 52, 53, 53, 53, 54, 54, 55, 55, 55, 55} },
{ 89912 , {37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 44, 44, 45, 46, 46, 47, 48, 48, 49, 49, 50, 51, 51, 52, 52, 53, 53, 53, 54, 54, 54, 54} },
{ 91638 , {37, 37, 37, 38, 39, 39, 40, 41, 41, 42, 43, 43, 44, 44, 45, 46, 46, 47, 48, 48, 49, 49, 50, 51, 51, 52, 52, 53, 53, 53, 53, 53} },
{ 93398 , {37, 37, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 44, 44, 45, 46, 46, 47, 47, 48, 48, 49, 50, 50, 51, 51, 52, 52, 52, 52, 52} },
{ 95191 , {36, 36, 37, 37, 37, 37, 38, 39, 39, 40, 41, 41, 42, 43, 43, 44, 44, 45, 46, 46, 47, 47, 48, 49, 49, 50, 50, 51, 51, 51, 51, 51} },
{ 97019 , {36, 36, 36, 37, 37, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 46, 47, 48, 48, 49, 49, 50, 50, 50, 50, 50} },
{ 98882 , {36, 36, 36, 36, 37, 37, 37, 37, 37, 38, 39, 39, 40, 40, 41, 42, 42, 43, 44, 44, 45, 46, 46, 46, 47, 48, 48, 49, 49, 49, 49, 49} },
{ 100780 , {35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 44, 45, 46, 46, 46, 47, 48, 48, 48, 48, 48} },
{ 102715 , {35, 35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 38, 39, 39, 40, 40, 41, 41, 42, 43, 43, 44, 44, 45, 46, 46, 47, 47, 47, 47, 47} },
{ 104688 , {35, 35, 35, 35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 39, 39, 40, 40, 41, 42, 42, 43, 43, 44, 44, 45, 46, 46, 46, 46, 46} },
{ 106698 , {34, 35, 35, 35, 35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 38, 39, 39, 40, 40, 41, 41, 42, 42, 43, 43, 44, 45, 45, 45, 45, 45} },
{ 108746 , {34, 34, 34, 35, 35, 35, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 39, 39, 40, 40, 41, 41, 42, 43, 43, 44, 44, 44, 44, 44} },
{ 110834 , {34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 38, 38, 39, 39, 40, 40, 41, 41, 42, 43, 43, 43, 43, 43} },
{ 112963 , {34, 34, 34, 34, 34, 34, 35, 35, 35, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 38, 38, 39, 39, 40, 40, 41, 41, 42, 42, 42, 42} },
{ 115132 , {33, 33, 34, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 38, 37, 39, 39, 40, 40, 41, 41, 41, 41} },
{ 117342 , {33, 33, 33, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 38, 37, 38, 40, 40, 40, 40, 40} },
{ 119595 , {32, 33, 33, 33, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39} },
{ 121892 , {32, 32, 32, 33, 33, 33, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 38, 38, 38, 38} },
{ 124232 , {32, 32, 32, 32, 33, 33, 33, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 37, 37} },
{ 126618 , {31, 32, 32, 32, 32, 32, 33, 33, 33, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37} },
{ 129049 , {31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37} },
{ 131527 , {31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 36} },
{ 134052 , {30, 31, 31, 31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36} },
{ 136626 , {30, 30, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36} },
{ 139249 , {30, 30, 30, 30, 31, 31, 31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 35} },
{ 141923 , {29, 30, 30, 30, 30, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35} },
{ 144648 , {29, 29, 29, 30, 30, 30, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35} },
{ 147426 , {29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 34} },
{ 150256 , {29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34} },
{ 153141 , {28, 28, 29, 29, 29, 29, 29, 30, 30, 30, 30, 131, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34} },
{ 156082 , {28, 28, 28, 129, 29, 29, 29, 29, 29, 30, 30, 30, 30, 131, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 34, 34} },
{ 159079 , {27, 28, 28, 28, 129, 29, 29, 29, 29, 29, 30, 30, 30, 30, 131, 131, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33} },
{ 162133 , {27, 27, 27, 28, 28, 28, 129, 29, 29, 29, 29, 29, 30, 30, 30, 30, 131, 131, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 33} },
{ 165246 , {27, 27, 27, 27, 28, 28, 28, 129, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 131, 131, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32} },
{ 168419 , {26, 26, 27, 27, 27, 27, 28, 28, 28, 129, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 131, 131, 31, 31, 31, 31, 31, 31, 33, 32, 33, 32} },
{ 171653 , {26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 129, 29, 29, 29, 29, 29, 130, 30, 30, 30, 131, 131, 131, 31, 31, 31, 31, 31, 31, 31, 33} },
{ 174949 , {26, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 129, 129, 29, 29, 29, 29, 29, 130, 30, 30, 30, 131, 131, 131, 131, 31, 31, 31, 31, 31} },
{ 178308 , {25, 26, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 129, 129, 29, 29, 29, 29, 130, 130, 130, 30, 30, 131, 131, 131, 131, 131, 31, 31} },
{ 181732 , {25, 25, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 129, 129, 129, 29, 29, 29, 130, 130, 130, 131, 30, 131, 131, 131, 131, 131} },
{ 185221 , {25, 25, 25, 25, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 28, 28, 28, 129, 129, 129, 29, 29, 29, 29, 130, 130, 130, 131, 131, 30, 30, 30} },
{ 188778 , {24, 24, 25, 25, 25, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 129, 129, 129, 29, 130, 29, 29, 130, 130, 130, 130, 130, 130} },
{ 192402 , {24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 26, 128, 27, 27, 27, 27, 28, 28, 28, 28, 129, 129, 129, 129, 29, 130, 29, 130, 130, 130, 130} },
{ 196097 , {24, 24, 24, 24, 24, 25, 25, 25, 127, 26, 26, 26, 26, 26, 128, 128, 27, 27, 27, 28, 28, 28, 28, 129, 129, 129, 129, 129, 130, 29, 130, 29} },
{ 199862 , {23, 24, 24, 24, 24, 24, 25, 25, 25, 25, 127, 127, 26, 26, 26, 26, 128, 128, 27, 27, 27, 28, 28, 28, 28, 129, 129, 129, 129, 129, 129, 130} },
{ 203700 , {23, 23, 125, 24, 24, 24, 24, 24, 25, 25, 25, 25, 127, 127, 26, 26, 26, 26, 128, 128, 27, 27, 27, 28, 28, 28, 28, 129, 129, 129, 129, 129} },
{ 207611 , {23, 23, 23, 23, 24, 24, 24, 24, 24, 25, 25, 25, 25, 127, 127, 127, 128, 26, 26, 128, 128, 128, 128, 27, 27, 27, 28, 28, 28, 28, 28, 28} },
{ 211597 , {22, 22, 23, 23, 23, 125, 24, 24, 24, 24, 24, 25, 25, 25, 25, 127, 127, 127, 26, 26, 26, 128, 128, 128, 128, 128, 27, 27, 27, 28, 28, 28} },
{ 215660 , {22, 22, 22, 23, 23, 23, 23, 125, 24, 24, 24, 24, 24, 25, 25, 25, 25, 127, 127, 127, 26, 128, 26, 128, 128, 128, 128, 128, 128, 28, 28, 28} },
{ 219801 , {22, 22, 22, 22, 22, 23, 23, 23, 125, 125, 24, 24, 24, 24, 126, 126, 25, 25, 25, 127, 127, 127, 127, 128, 128, 128, 128, 128, 128, 128, 128, 28} },
{ 224021 , {22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 125, 125, 24, 24, 24, 24, 126, 126, 127, 25, 127, 127, 127, 127, 127, 127, 128, 26, 128, 128, 128, 128} },
{ 228323 , {21, 114, 114, 22, 22, 22, 22, 22, 23, 23, 23, 23, 125, 125, 126, 24, 24, 24, 126, 126, 127, 127, 127, 127, 127, 127, 127, 127, 26, 128, 128, 128} },
{ 232707 , {21, 21, 21, 114, 114, 22, 22, 22, 22, 22, 23, 23, 23, 125, 125, 125, 24, 126, 24, 24, 126, 126, 126, 127, 127, 127, 127, 127, 127, 127, 127, 127} },
{ 237175 , {20, 21, 21, 21, 114, 114, 116, 116, 22, 22, 22, 23, 23, 23, 23, 125, 125, 125, 125, 24, 126, 24, 126, 126, 126, 126, 127, 127, 127, 127, 127, 127} },
{ 241729 , {20, 20, 20, 21, 21, 21, 114, 114, 116, 123, 22, 22, 22, 23, 23, 23, 23, 125, 125, 125, 125, 125, 24, 126, 126, 126, 126, 126, 127, 127, 127, 127} },
{ 246371 , {19, 20, 20, 20, 21, 21, 21, 114, 114, 116, 116, 123, 123, 22, 22, 23, 23, 23, 23, 125, 125, 125, 125, 125, 126, 126, 126, 126, 126, 126, 126, 127} },
{ 251101 , {19, 19, 20, 20, 20, 20, 21, 21, 21, 114, 114, 116, 116, 123, 123, 123, 22, 23, 23, 23, 23, 125, 125, 125, 125, 125, 125, 24, 126, 126, 126, 126} },
{ 255923 , {19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 114, 114, 114, 116, 123, 123, 123, 123, 22, 22, 23, 23, 23, 125, 125, 125, 125, 125, 125, 125, 126, 126} },
{ 260836 , {19, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 114, 114, 114, 116, 123, 123, 123, 123, 123, 123, 23, 23, 23, 125, 125, 125, 125, 125, 125, 125} },
{ 265845 , {18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 114, 114, 116, 116, 123, 123, 123, 123, 123, 123, 123, 23, 23, 23, 125, 125, 125, 125} },
{ 270949 , {18, 18, 18, 112, 19, 19, 19, 19, 19, 113, 20, 20, 20, 114, 21, 21, 114, 114, 116, 116, 123, 123, 123, 123, 123, 123, 123, 23, 23, 125, 125, 125} },
{ 276152 , {17, 18, 18, 18, 18, 112, 19, 19, 19, 19, 113, 113, 20, 20, 114, 114, 114, 21, 114, 114, 116, 116, 123, 123, 123, 123, 123, 123, 123, 123, 123, 125} },
{ 281454 , {17, 17, 17, 18, 18, 18, 112, 112, 112, 19, 19, 19, 113, 113, 20, 20, 114, 114, 114, 114, 114, 114, 116, 116, 123, 123, 123, 123, 123, 123, 123, 123} },
{ 286858 , {16, 17, 17, 17, 18, 18, 18, 18, 112, 112, 112, 19, 19, 19, 113, 113, 113, 20, 114, 114, 114, 114, 114, 114, 116, 116, 123, 123, 123, 123, 123, 123} },
{ 292366 , {16, 16, 110, 17, 17, 17, 18, 18, 18, 18, 112, 112, 122, 122, 19, 19, 113, 113, 113, 113, 114, 114, 114, 114, 114, 114, 116, 116, 123, 123, 123, 123} },
{ 297980 , {16, 16, 16, 16, 110, 17, 17, 17, 18, 18, 18, 112, 112, 112, 122, 122, 19, 113, 113, 113, 113, 113, 114, 114, 114, 114, 114, 114, 114, 114, 116, 116} },
{ 303702 , {15, 16, 16, 16, 16, 16, 110, 110, 17, 18, 18, 18, 18, 112, 112, 112, 122, 122, 122, 113, 19, 113, 113, 113, 113, 113, 114, 114, 114, 114, 114, 114} },
{ 309533 , {15, 15, 16, 16, 16, 16, 16, 110, 110, 120, 120, 121, 18, 18, 18, 112, 112, 112, 122, 122, 122, 122, 113, 113, 113, 113, 113, 114, 114, 114, 114, 114} },
{ 315476 , {14, 15, 15, 15, 16, 16, 16, 16, 16, 110, 110, 120, 120, 121, 121, 112, 18, 112, 112, 112, 122, 122, 122, 122, 122, 122, 122, 122, 122, 114, 114, 114} },
{ 321534 , {14, 14, 119, 15, 15, 15, 16, 16, 16, 16, 16, 110, 110, 120, 120, 121, 121, 121, 112, 112, 112, 112, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122} },
{ 327708 , {14, 14, 14, 14, 119, 119, 15, 16, 16, 16, 16, 16, 110, 110, 110, 120, 120, 121, 121, 121, 112, 122, 112, 112, 122, 122, 122, 122, 122, 122, 122, 122} },
{ 334000 , {12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 110, 110, 110, 112, 112, 112, 112} },
{ 340413 , {12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 110, 110, 110, 110, 110} },
{ 346949 , {11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16} },
{ 353611 , {11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 16, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16} },
{ 360401 , {11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 111, 111, 14, 14, 14, 16, 16, 16, 16, 16, 16, 16, 16, 16} },
{ 367321 , {11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 109, 13, 13, 13, 13, 13, 13, 13, 111, 111, 110, 110, 110, 110, 110, 110, 16, 16, 16, 16} },
{ 374374 , {10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 109, 109, 109, 109, 109, 118, 13, 13, 118, 118, 111, 111, 110, 110, 110, 110, 110, 110} },
{ 381562 , {10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 109, 109, 109, 109, 109, 118, 118, 118, 118, 118, 118, 119, 119, 119, 111, 110} },
{ 388889 , {10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 109, 109, 109, 109, 109, 118, 118, 118, 118, 118, 118, 118, 118, 118} },
{ 396356 , {9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 107, 107, 109, 109, 12, 12, 109, 109, 109, 109, 109, 118, 118, 118, 118, 118, 118, 118} },
{ 403966 , {9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 107, 107, 107, 109, 109, 109, 109, 109, 109, 109, 109, 109, 118, 118, 118, 118} },
{ 411723 , {9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 107, 107, 107, 117, 117, 118, 118, 118, 118, 118, 118, 118, 118, 118} },
{ 419628 , {9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 107, 107, 117, 117, 117, 117, 118, 118, 118, 118, 118} },
{ 427686 , {8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 107, 107, 117, 117, 117, 117, 117, 119, 119} },
{ 435898 , {8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 107, 107, 107, 117, 117, 117, 117} },
{ 444267 , {8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 107, 107, 107, 107} },
{ 452798 , {8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11} },
{ 461492 , {8, 8, 8, 8, 8, 8, 8, 8, 8, 105, 105, 9, 9, 9, 9, 9, 9, 106, 106, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11} },
{ 470353 , {7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 105, 105, 105, 105, 105, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 11, 11} },
{ 479384 , {7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 105, 105, 105, 105, 105, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106} },
{ 488589 , {6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 105, 105, 105, 105, 105, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106} },
{ 497970 , {6, 6, 6, 7, 7, 7, 7, 102, 8, 8, 8, 8, 8, 8, 8, 8, 8, 104, 105, 105, 105, 105, 105, 106, 106, 106, 106, 106, 106, 106, 106, 106} },
{ 507532 , {5, 6, 6, 6, 6, 7, 7, 7, 7, 102, 102, 102, 103, 103, 103, 103, 104, 104, 104, 104, 106, 105, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106} },
{ 517277 , {5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 102, 102, 102, 103, 103, 103, 103, 103, 104, 104, 104, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106} },
{ 527209 , {5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 102, 102, 102, 103, 103, 103, 103, 103, 104, 104, 104, 104, 104, 104, 104, 104, 106, 106, 106} },
{ 537332 , {5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 102, 102, 102, 103, 103, 103, 103, 103, 103, 104, 104, 104, 104, 104, 104, 104, 104} },
{ 547650 , {4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 101, 101, 7, 7, 102, 102, 102, 103, 103, 103, 103, 103, 104, 104, 104, 104, 104, 104} },
{ 558165 , {4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 101, 101, 101, 101, 102, 102, 102, 103, 103, 103, 103, 103, 103, 103, 103, 103} },
{ 568882 , {4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 101, 101, 101, 101, 102, 102, 102, 102, 103, 103, 103, 103, 103, 103} },
{ 579805 , {4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 101, 101, 101, 101, 101, 102, 102, 102, 103, 103, 103, 103} },
{ 590938 , {4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 101, 101, 101, 101, 102, 102, 102, 102, 102} },
{ 602285 , {2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 101, 101, 101, 101, 101, 101, 101} },
{ 613849 , {2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 99, 99, 99, 99, 99, 99, 99, 99, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101} },
{ 625636 , {2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 99, 99, 99, 99, 99, 99, 99, 99, 99, 101, 101, 101, 101, 101, 101, 101, 101} },
{ 637649 , {2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 99, 99, 99, 99, 99, 99, 99, 99, 99, 101, 101, 101, 101, 101} },
{ 649892 , {2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99} },
{ 662371 , {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 98, 98, 98, 98, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99} },
{ 675089 , {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 98, 98, 98, 98, 98, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99} },
{ 688052 , {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 98, 98, 98, 98, 98, 98, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99} },
{ 701263 , {1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 98, 98, 98, 98, 98, 98, 99, 99, 99, 99, 99, 99, 99} },
{ 714728 , {1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 98, 98, 98, 98, 98, 98, 99, 99, 99, 99, 99} },
{ 728451 , {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 98, 98, 98, 98, 98, 98, 98, 98} },
{ 742438 , {1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 98, 98, 98, 98, 98} },
{ 756694 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2} },
{ 771223 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2} },
{ 786031 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2} },
{ 801124 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2} },
{ 816507 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2} },
{ 832184 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2} },
{ 848163 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2} },
{ 864449 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2} },
{ 881047 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2} }
};
typedef struct _TDA18275_second_order_def_
{
    Int32 x0;
    Int32 x1;
    Int32 x2;
} TDA18275_second_order_def;

typedef struct _TDA18275_max_gain_map_def_
{
    UInt32 RF;
    TDA18275_second_order_def eq;
} TDA18275_max_gain_map_def;

typedef struct _TDA18275_AGC1_gain_map_def_
{
    TDA18275_second_order_def eq;
} TDA18275_AGC1_gain_map_def;

static TDA18275_max_gain_map_def  TDA18275_max_gain_map[5] =
{
{0, {667356627, 770613, -28580}},
{180, {721098730, -9914, -663}},
{470, {887342380, -644882, 5564}},
{670, {692536833, 147116, -1828}},
{870, {679245077, 164350, -1827}}
};
static TDA18275_max_gain_map_def  TDA18275_max_gain_map_all_pass[5] =
{
{0, {658288353, 797675, -29814}},
{180, {716158863, -40802, 243}},
{470, {732047223, -89289, 602}},
{670, {597529820, 331257, -2677}},
{870, {675111260, 170875, -1851}}
};

static TDA18275_second_order_def  TDA18275_AGC1_gain_map[12] =
{
{-319161060, -27083, 453},
{-291822337, -19605, 357},
{-263351683, -13359, 294},
{-234249100, -11712, 271},
{-204395520, -11847, 282},
{-175445833, -6338, 230},
{-149473533, -5592, 205},
{-118116107, -2866, 167},
{-88949868, -3155, 154},
{-60558196, -1514, 121},
{-30531181, -3531, 93},
{0, 0, 0}
};

static TDA18275_second_order_def  TDA18275_AGC2_gain_map[142] =
{
{-163287443, -1054, 232},
{-163228813, -1588, 238},
{-160950813, -486, 228},
{-160815350, -1276, 237},
{-158627913, -1010, 235},
{-158638937, -857, 234},
{-156400653, -82, 227},
{-156401137, -315, 231},
{-153985137, -1058, 238},
{-154039080, -853, 236},
{-152738640, -201, 229},
{-150264070, -1611, 243},
{-150408557, -1025, 240},
{-147655693, -1752, 244},
{-147583470, -2238, 248},
{-145480133, -1519, 244},
{-145345253, -1937, 247},
{-143000620, -2102, 247},
{-142971570, -1984, 245},
{-141598840, -1813, 245},
{-140376847, -1291, 239},
{-139340620, -1811, 244},
{-137014997, -1727, 245},
{-136865823, -1787, 243},
{-134720690, -999, 237},
{-134539533, -1462, 241},
{-132164000, -1945, 244},
{-132174580, -1885, 244},
{-129375860, -2256, 248},
{-129375083, -2267, 247},
{-128376550, -1926, 242},
{-126118447, -1586, 240},
{-126285083, -528, 229},
{-123894357, -1093, 236},
{-123855543, -1058, 236},
{-121678517, -705, 232},
{-121496760, -1267, 236},
{-119014817, -1099, 237},
{-118869973, -1867, 242},
{-117919463, -1546, 239},
{-117073820, -914, 234},
{-115790103, -625, 231},
{-113151587, -1882, 241},
{-113321283, -1116, 235},
{-110946300, -1853, 241},
{-110961253, -1951, 242},
{-108412240, -1403, 237},
{-108305020, -1946, 242},
{-107193627, -2005, 240},
{-106212000, -1495, 234},
{-104996943, -1230, 232},
{-102461117, -1866, 236},
{-102454210, -1625, 233},
{-100316237, -950, 226},
{-100389133, -564, 222},
{-97436673, -1786, 233},
{-97532511, -1468, 230},
{-96583121, -1145, 225},
{-95625166, -111, 212},
{-94208935, -290, 212},
{-92694168, -628, 215},
{-91946500, 188, 209},
{-89619048, -244, 209},
{-89713414, 499, 203},
{-86796057, -945, 216},
{-86826784, -419, 211},
{-85969713, 26, 205},
{-84979777, 743, 197},
{-83509401, -6, 202},
{-82173781, 973, 192},
{-81447897, 1659, 186},
{-78952798, 597, 194},
{-79095986, 1301, 187},
{-76383871, 1370, 184},
{-76472844, 1666, 181},
{-74427385, 1841, 176},
{-74566577, 2399, 171},
{-73294006, 2158, 172},
{-71842944, 2309, 171},
{-71031827, 2719, 167},
{-70039643, 2751, 165},
{-68759501, 2536, 165},
{-66158149, 2243, 166},
{-66107623, 2354, 163},
{-64166208, 2435, 159},
{-64181358, 2262, 161},
{-62762049, 1718, 164},
{-61383383, 2215, 158},
{-60608392, 2325, 157},
{-59611192, 2123, 158},
{-58311039, 1528, 163},
{-55719431, 1512, 158},
{-55636942, 1093, 160},
{-53751332, 1884, 149},
{-53666184, 1454, 152},
{-52532736, 2072, 146},
{-50953773, 1438, 151},
{-50117405, 978, 158},
{-49244761, 1354, 154},
{-48004230, 1131, 153},
{-46653363, 1129, 154},
{-45381266, 544, 155},
{-43495821, 1325, 139},
{-43430077, 875, 144},
{-42284208, 1151, 138},
{-40763401, 949, 140},
{-39820252, 131, 147},
{-38854061, 338, 142},
{-37636648, -25, 143},
{-36355499, 20, 142},
{-35038723, -315, 138},
{-33088791, -279, 129},
{-33036194, -362, 129},
{-31986012, 166, 124},
{-30567078, 11, 124},
{-29688920, -243, 123},
{-28705150, -128, 119},
{-27591128, 27, 112},
{-26212387, -136, 115},
{-24966104, 12, 107},
{-23853374, -783, 107},
{-22781505, -805, 103},
{-20185337, -451, 93},
{-20083247, -622, 93},
{-19292272, -995, 94},
{-18192857, -1330, 94},
{-17044077, -1116, 87},
{-15896263, -533, 81},
{-14301726, -774, 68},
{-13024863, -133, 62},
{-11742350, -859, 60},
{-10630474, -428, 52},
{-9891196, 64, 44},
{-8823770, 515, 38},
{-7697626, 463, 30},
{-6004830, 184, 31},
{-5261770, 231, 21},
{-4509237, 83, 18},
{-3116770, -429, 15},
{-2486010, 786, 3},
{-1077459, 52, 6},
{0, 0, 0}
};

/*============================================================================*/
/* Exported functions:                                                        */
/*============================================================================*/

/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_Open:                                           */
/*                                                                            */
/* DESCRIPTION: Opens driver setup environment.                               */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_Open(
    tmUnitSelect_t              tUnit,      /* I: FrontEnd unit number */
    tmbslFrontEndDependency_t*  psSrvFunc   /* I: setup parameters */
)
{
    pTDA18275Object_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Test parameter(s) */
    if(psSrvFunc == Null)
    {
        err = TDA18275_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        /* Get a driver instance */
        err = iTDA18275_GetInstance(tUnit, &pObj);
    }

    /* Check driver instance state */
    if(err == TM_OK || err == TDA18275_ERR_ERR_NO_INSTANCES)
    {
        if(P_OBJ_VALID && pObj->init == True)
        {
            err = TDA18275_ERR_ALREADY_SETUP;
        }
        else
        {
            if(P_OBJ_VALID == False)
            {
                /* Try to allocate an instance of the driver */
                err = iTDA18275_AllocInstance(tUnit, &pObj);
                if(err != TM_OK || pObj == Null)
                {
                    err = TDA18275_ERR_ERR_NO_INSTANCES;
                }
            }

            if(err == TM_OK)
            {
                /* Initialize the Object by default values */
                P_SIO = P_FUNC_SIO(psSrvFunc);
                P_STIME = P_FUNC_STIME(psSrvFunc);
                P_SDEBUG = P_FUNC_SDEBUG(psSrvFunc);

#ifdef _TVFE_IMPLEMENT_MUTEX
                if(    P_FUNC_SMUTEX_OPEN_VALID(psSrvFunc)
                    && P_FUNC_SMUTEX_CLOSE_VALID(psSrvFunc)
                    && P_FUNC_SMUTEX_ACQUIRE_VALID(psSrvFunc)
                    && P_FUNC_SMUTEX_RELEASE_VALID(psSrvFunc) )
                {
                    P_SMUTEX = psSrvFunc->sMutex;

                    err = P_SMUTEX_OPEN(&P_MUTEX);
                    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "Mutex_Open(0x%08X) failed.", tUnit));
                }
#endif

                tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA18275_Open(0x%08X)", tUnit);

                if(err == TM_OK)
                {
                    pObj->init = True;
                }
            }
        }
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_Close:                                          */
/*                                                                            */
/* DESCRIPTION: Closes driver setup environment.                              */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_Close(
    tmUnitSelect_t  tUnit   /* I: FrontEnd unit number */
)
{
    pTDA18275Object_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA18275_GetInstance(tUnit, &pObj);

    if(err == TM_OK)
    {
#ifdef _TVFE_IMPLEMENT_MUTEX
        /* Try to acquire driver mutex */
        err = iTDA18275_MutexAcquire(pObj, TDA18275_MUTEX_TIMEOUT);

        if(err == TM_OK)
        {
#endif
            tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA18275_Close(0x%08X)", tUnit);

#ifdef _TVFE_IMPLEMENT_MUTEX
            P_SMUTEX_ACQUIRE = Null;

            /* Release driver mutex */
            (void)iTDA18275_MutexRelease(pObj);

            if(P_SMUTEX_CLOSE_VALID && P_MUTEX_VALID)
            {
                err = P_SMUTEX_CLOSE(P_MUTEX);
            }

            P_SMUTEX_OPEN = Null;
            P_SMUTEX_CLOSE = Null;
            P_SMUTEX_RELEASE = Null;

            P_MUTEX = Null;
        }
#endif

        err = iTDA18275_DeAllocInstance(pObj);
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_GetSWVersion:                                   */
/*                                                                            */
/* DESCRIPTION: Gets the versions of the driver.                              */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_GetSWVersion(
    ptmSWVersion_t  pSWVersion  /* I: Receives SW Version */
)
{
    pSWVersion->compatibilityNr = TDA18275_COMP_NUM;
    pSWVersion->majorVersionNr  = TDA18275_MAJOR_VER;
    pSWVersion->minorVersionNr  = TDA18275_MINOR_VER;

    return TM_OK;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_GetSWSettingsVersion:                           */
/*                                                                            */
/* DESCRIPTION: Returns the version of the driver settings.                   */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_GetSWSettingsVersion(
    ptmSWSettingsVersion_t pSWSettingsVersion   /* O: Receives SW Settings Version */
)
{
    pSWSettingsVersion->customerNr      = TDA18275_SETTINGS_CUSTOMER_NUM;
    pSWSettingsVersion->projectNr       = TDA18275_SETTINGS_PROJECT_NUM;
    pSWSettingsVersion->majorVersionNr  = TDA18275_SETTINGS_MAJOR_VER;
    pSWSettingsVersion->minorVersionNr  = TDA18275_SETTINGS_MINOR_VER;

    return TM_OK;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_SetPowerState                                   */
/*                                                                            */
/* DESCRIPTION: Sets the power state.                                         */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_SetPowerState(
    tmUnitSelect_t  tUnit,      /* I: Unit number */
    tmPowerState_t  powerState  /* I: Power state */
 )
{
    pTDA18275Object_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA18275_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA18275)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA18275_SetPowerState(0x%08X)", tUnit);

    if(powerState>=tmPowerMax)
    {
        err = TDA18275_ERR_BAD_PARAMETER;
    }
    if(err == TM_OK)
    {
        if(pObj->mapLLPowerState[powerState] != pObj->curLLPowerState)
        {
            err = iTDA18275_SetLLPowerState(pObj, pObj->mapLLPowerState[powerState]);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_SetLLPowerState(0x%08X, %d) failed.", tUnit, (int)pObj->mapLLPowerState[powerState]));

            if(err == TM_OK)
            {
                /* Store power state in driver instance */
                pObj->curPowerState = powerState;
            }
        }
    }

    _MUTEX_RELEASE(TDA18275)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_GetPowerState:                                  */
/*                                                                            */
/* DESCRIPTION: Gets the power state.                                         */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_GetPowerState(
    tmUnitSelect_t  tUnit,      /* I: Unit number */
    tmPowerState_t* pPowerState /* O: Power state */
)
{
    pTDA18275Object_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA18275_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA18275)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA18275_GetPowerState(0x%08X)", tUnit);

    /* Test parameter(s) */
    if(pPowerState == Null)
    {
        err = TDA18275_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        *pPowerState = pObj->curPowerState;
    }

    _MUTEX_RELEASE(TDA18275)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_SetStandardMode                                 */
/*                                                                            */
/* DESCRIPTION: Sets the standard mode.                                       */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_SetStandardMode(
    tmUnitSelect_t          tUnit,          /* I: Unit number */
    TDA18275StandardMode_t  StandardMode    /* I: Standard mode of this device */
)
{
    pTDA18275Object_t           pObj = Null;
    tmErrorCode_t               err = TM_OK;
    UInt8 uMinor=0, uMajor=0;
    UInt16  uIdentity=0;

    /* Get a driver instance */
    err = iTDA18275_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA18275)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA18275_SetStandardMode(0x%08X)", tUnit);
    if(err == TM_OK)
    {
        pObj->StandardMode = StandardMode;
        pObj->pStandard = &pObj->Std_Array[pObj->StandardMode - 1];
        pObj->uIF = pObj->pStandard->IF;

        err = iTDA18275_Read(pObj, &gTDA18275_Reg_ID_byte_3__Minor_rev, &uMinor, Bus_None );
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_ID_byte_3__Major_rev, &uMajor, Bus_None );
        err = iTDA18275_GetIdentity(pObj, &uIdentity);

        /****************************************************************/
        /* IF SELECTIVITY Settings                                      */
        /****************************************************************/

        /* Set LPFc */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_Byte_1__LP_Fc, pObj->pStandard->LPF, Bus_None);

        /* Set LPFc Offset */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_Byte_1__IF_LPF_Offset,(UInt8)(pObj->pStandard->LPF_Offset), Bus_None);

        /* Set LPF Offset sign */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_Byte_1__IF_LPF_sign, (UInt8)(pObj->pStandard->LPF_sign), Bus_None);

        /* Set DC_Notch_IF_PPF */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_Byte_1__DC_Notch, pObj->pStandard->DC_Notch_IF_PPF, Bus_None);

        /* Set Hi Pass Enable */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_Byte_2__IF_HP_Enable, pObj->pStandard->HP_Enable, Bus_None);

        /* Set HP Fc  */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_Byte_2__IF_HP_Fc, pObj->pStandard->HPF, Bus_None);

        /* Set HP Offset  */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_Byte_2__IF_HPF_Offset, pObj->pStandard->HPF_Offset, Bus_None);

        /* Set HP Offset sign  */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_Byte_2__IF_HPF_sign, pObj->pStandard->HPF_sign, Bus_None);

        /* Set IF Notch Enable */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_Byte_3__IF_Notch_Enable, pObj->pStandard->IF_Notch_Enable, Bus_None);

        /* Set IF Notch Freq */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_Byte_3__IF_Notch_Freq, pObj->pStandard->IF_Notch_Freq, Bus_None);

        /* SetIF Notch Offset  */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_Byte_3__IF_Notch_Offset, pObj->pStandard->IF_Notch_Offset, Bus_None);

        /* Set IF Notch Offset sign  */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_Byte_3__IF_Notch_sign, pObj->pStandard->IF_Notch_sign, Bus_None);

        /* Set  IFnotchToRSSI   */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_AGC_byte__IFnotchToRSSI, pObj->pStandard->IFnotchToRSSI, Bus_None);


        /****************************************************************/
        /* AGC TOP Settings                                             */
        /****************************************************************/

        /* Set AGC1 TOP I2C DN/UP */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC1_byte_1__AGC1_Top, pObj->pStandard->AGC1_TOP_I2C_DN_UP, Bus_None);

        /* Set  AGC1 TOP STRATEGY  */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC1_byte_1__AGC1_Top_Strategy, pObj->pStandard->AGC1_TOP_STRATEGY, Bus_None);

        /* Set  AGC1_Do_step  */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC1_byte_3__AGC1_Do_step, pObj->pStandard->AGC1_Do_step, Bus_None);

        /* Set  AGC2 TOP I2C DN/UP no write  */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC2_byte_1__AGC2_TOP, pObj->pStandard->AGC2_TOP_I2C_DN_UP, Bus_None);

        /* Set  AGC2 TOP STRATEGY, ! final write Reg_AGC2_byte_1  */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC2_byte_1__AGC2_Top_Strategy, pObj->pStandard->AGC2_Top_Strategy, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));

        if(err == TM_OK)
        {

            /* Set  AGC2_Do_step  */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_RF_byte__AGC2_Do_step, pObj->pStandard->AGC2_Do_step, Bus_None);

            /* Set  AGC4 TOP I2C DN/UP   */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_IR_Mixer_byte_1__AGC4_TOP, pObj->pStandard->AGC4_TOP_I2C_DN_UP, Bus_None);

            /* Set  AGC4_Do_step  */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_IR_Mixer_byte_2__AGC4_Do_step, pObj->pStandard->AGC4_Do_step, Bus_None);

            /* Set  AGC5 TOP I2C DN/UP   */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC5_byte_1__AGC5_TOP, pObj->pStandard->AGC5_TOP_I2C_DN_UP, Bus_None);

            /* Set  AGC5_Do_step  */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC5_byte_2__AGC5_Do_step, pObj->pStandard->AGC5_Do_step, Bus_None);

            /* Set  AGC1 TOP adapt   */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_Adapt_Top_byte__Top_adapt_AGC1, pObj->pStandard->AGC1_Adapt_TOP, Bus_None);

            /* Set  AGC2 TOP adapt   */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_Adapt_Top_byte__Top_adapt_AGC2, pObj->pStandard->AGC2_Adapt_TOP, Bus_None);

            /* Set  IF Output Level   ! final write Reg_IF_AGC_byte */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_AGC_byte__IF_level, pObj->pStandard->IF_Output_Level, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
        }
        if(err == TM_OK)
        {

            /* Set  AGC Overload TOP */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_Ovld_Udld_byte__AGC_Ovld_TOP, pObj->pStandard->AGC_Overload_TOP, Bus_None);

            /* Set  AGC2 Gain Control Speed  */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC1_byte_2__AGC2_Gain_Control_Speed, pObj->pStandard->AGC2_Gain_Control_Speed, Bus_None);

            /* Set  AGC1_cc_Freeze  */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC1_byte_2__AGC1_cc_Freeze_Enable, (UInt8)pObj->pStandard->AGC1_cc_Freeze_Enable, Bus_None);

            /* Set  AGC1_cc_Wide  */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC1_byte_2__AGC1_cc_Wide_Enable, (UInt8)pObj->pStandard->AGC1_cc_Wide_Enable, Bus_None);

            /* Set PD Vsync_Mgt  */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_Vsync_byte__PD_Vsync_Mgt, pObj->pStandard->PD_Vsync_Mgt, Bus_None);

            /* Set Negative modulation  */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_Vsync_byte__Neg_Modulation, pObj->pStandard->Neg_Modulation, Bus_None);

            /* Set AGCK Mode  */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGCK_byte_1__AGCK_Mode, pObj->pStandard->AGCK_Mode, Bus_None);

            /* Set AGC5_HP_Fc  */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC5_byte_1__AGC5_HP_Fc, pObj->pStandard->AGC5_HP_Fc, Bus_None);

            /* Set RSSI_HP_Fc  */
            if (uIdentity== TDA18275_Identity && uMajor==1 && (uMinor <= 2 || uMinor==4))
            { /* coding inverted in ES1a, ES1b, ES1c, ES1a_MF */
                if (pObj->pStandard->RSSI_HP_Fc == TDA18275_RSSI_HP_Fc_0d3_MHz)
                {
                    err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC5_byte_1__RSSI_HP_Fc, TDA18275_RSSI_HP_Fc_2d25_MHz, Bus_None);
                }
                else
                {
                    err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC5_byte_1__RSSI_HP_Fc, TDA18275_RSSI_HP_Fc_0d3_MHz, Bus_None);
                }
            }
            else
            {   /* normal coding in other versions ES1' and further */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC5_byte_1__RSSI_HP_Fc, pObj->pStandard->RSSI_HP_Fc, Bus_None);
            }

            /* Set Det6_Cap_Val   no write */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_RSSI_byte_2__Det6_Cap_Val, pObj->pStandard->Det6_Cap_Val, Bus_None);

            /* Set RSSI_AV  no write */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_RSSI_byte_2__RSSI_AV, pObj->pStandard->RSSI_AV, Bus_None);

            /* Set RSSI_Ck_Speed final write  ! final write Reg_RSSI_byte_2 */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_RSSI_byte_2__RSSI_Ck_Speed, pObj->pStandard->RSSI_Ck_Speed, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
        }
		if(err == TM_OK)
        {
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_RF_Filters_byte_1__LNA_Highpass, pObj->pStandard->LNA_Highpass, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
        }
		if(err == TM_OK)
		{
            /* Set _DIFOUT_En  */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_AGC_byte__DIFOUT_En, pObj->pStandard->DIFOUT_En, Bus_None);

            /* Set  DVIFAGC_En */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_AGC_byte__DVIFAGC_En, pObj->pStandard->DVIFAGC_En, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
        }
		if(err == TM_OK)
		{
			err = iTDA18275_PowerSavingMode(pObj, pObj->pStandard->PowerSavingMode);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_PowerSavingMode(0x%08X) failed.", pObj->tUnitW));
		}

		/* Blocks final writting */
        if(err == TM_OK)
        {
            /* Write AGC1_byte_1, AGC1_byte_3   Registers */
            err = iTDA18275_WriteRegMap(pObj, gTDA18275_Reg_AGC1_byte_1.Address, TDA18275_REG_DATA_LEN(gTDA18275_Reg_AGC1_byte_1, gTDA18275_Reg_AGC1_byte_3));
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_WriteRegMap(0x%08X) failed.", pObj->tUnitW));
        }
        if(err == TM_OK)
        {
            /* Write RF_byte, AGCK_byte_1, IR_Mixer_byte_1 , IR_Mixer_byte_2 ,  AGC5_byte_1 , AGC5_byte_2 Registers */
            err = iTDA18275_WriteRegMap(pObj, gTDA18275_Reg_RF_byte.Address, TDA18275_REG_DATA_LEN(gTDA18275_Reg_RF_byte, gTDA18275_Reg_AGC5_byte_2));
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_WriteRegMap(0x%08X) failed.", pObj->tUnitW));
        }

        if(err == TM_OK)
        {
            /* Write Adapt_Top_byte, Vsync_byte, Ovld_Udld_byte, IF_Byte_1,  IF_Byte_2 , IF_Byte_3   Registers */
            err = iTDA18275_WriteRegMap(pObj, gTDA18275_Reg_Adapt_Top_byte.Address, TDA18275_REG_DATA_LEN(gTDA18275_Reg_Adapt_Top_byte, gTDA18275_Reg_IF_Byte_3));
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_WriteRegMap(0x%08X) failed.", pObj->tUnitW));
        }

        /* Update driver state machine */
        pObj->eHwState = TDA18275_HwState_SetStdDone;
    }

    _MUTEX_RELEASE(TDA18275)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_GetStandardMode                                 */
/*                                                                            */
/* DESCRIPTION: Gets the standard mode.                                       */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_GetStandardMode(
    tmUnitSelect_t          tUnit,          /* I: Unit number */
    TDA18275StandardMode_t  *pStandardMode  /* O: Standard mode of this device */
)
{
    pTDA18275Object_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA18275_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA18275)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA18275_GetStandardMode(0x%08X)", tUnit);

    if(pStandardMode == Null)
    {
        err = TDA18275_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        /* Get standard mode */
        *pStandardMode = pObj->StandardMode;
    }

    _MUTEX_RELEASE(TDA18275)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_SetRF:                                          */
/*                                                                            */
/* DESCRIPTION: Tunes to a RF.                                                */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_SetRF(
    tmUnitSelect_t  tUnit,  /* I: Unit number */
    UInt32          uRF     /* I: RF frequency in hertz */
)
{
    pTDA18275Object_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA18275_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA18275)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA18275_SetRF(0x%08X)", tUnit);

    /* Test parameter(s) */
    if(   pObj->StandardMode<=TDA18275_StandardMode_Unknown
       || pObj->StandardMode>=TDA18275_StandardMode_Max
       || pObj->pStandard == Null)
    {
        err = TDA18275_ERR_STD_NOT_SET;
    }

    if(err == TM_OK)
    {
        /* Check if Hw is ready to operate */
        err = iTDA18275_CheckHwState(pObj, TDA18275_HwStateCaller_SetRF);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_CheckHwState(0x%08X) failed.", pObj->tUnitW));
    }

    /* check Max RF supported 1002 Mhz */
    if(err == TM_OK && uRF > 1002000000 )
    {
        err = TDA18275_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        pObj->uRF = uRF;
        pObj->uLO = pObj->uRF + pObj->uIF;

        err = iTDA18275_SetRF(pObj);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_SetRF(0x%08X) failed.", tUnit));

        if(err == TM_OK)
        {
            /* Update driver state machine */
            pObj->eHwState = TDA18275_HwState_SetRFDone;
        }
    }

    if(err == TM_OK)
    {
        /* Update driver state machine */
        pObj->eHwState = TDA18275_HwState_SetRFDone;
    }

    _MUTEX_RELEASE(TDA18275)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_GetRF:                                          */
/*                                                                            */
/* DESCRIPTION: Gets tuned RF.                                                */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_GetRF(
    tmUnitSelect_t  tUnit,  /* I: Unit number */
    UInt32*         puRF    /* O: RF frequency in hertz */
)
{
    pTDA18275Object_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA18275_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA18275)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA18275_GetRF(0x%08X)", tUnit);

    if(puRF == Null)
    {
        err = TDA18275_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        /* Get RF */
        *puRF = pObj->uRF;
    }

    _MUTEX_RELEASE(TDA18275)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_HwInit:                                         */
/*                                                                            */
/* DESCRIPTION: Initializes TDA18275 Hardware.                                */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*   initial values needed, but ok from POR                                   */
/*    LOSD_Static_N = 1                                                       */
/*    agc1_highZ = 1                                                          */
/*    cp_cursel = 4                                                           */
/*    LO_Int = 0x72                                                           */
/*    VCO_Select = 0x02 ( VCO low)                                            */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_HwInit(
    tmUnitSelect_t  tUnit   /* I: Unit number */
)
{
    pTDA18275Object_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;
	UInt8 uVal=0, uMinor=0, uMajor=0;
    UInt32 counter = 10; /* Wait I2C ready */
    UInt16  uIdentity=0;

    /* Get a driver instance */
    err = iTDA18275_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA18275)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA18275_HwInit(0x%08X)", tUnit);

    /* Reset standard mode & Hw State */
    pObj->StandardMode = TDA18275_StandardMode_Max;
    pObj->eHwState = TDA18275_HwState_InitNotDone;

    /* Check I2C IC responding */
    while(counter > 0)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Test_byte__reset_i2c_dis, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
        if(err==TM_OK)
        {
            /* IC I2C responds */
            break;
        }
        if(counter)
        {
            /* Decrease the counter */
            counter--;
            /* Wait for a step of  1ms */
            err = iTDA18275_Wait(pObj, 1);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Wait(0x%08X) failed.", pObj->tUnitW));
        }
	}

    /* ensure Dig_Clock_16MHz before Digital part reset */
    if (err==TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Reference_Byte__Dig_Clock, TDA18275_Dig_Clock_16MHz, Bus_RW);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
    }

    /* perform soft reset and register set to POR  */
    if (err==TM_OK)
    {
        /* put tuner in POR state by soft reset ( state and machine and registers values */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Powerdown__force_soft_reset, 0x01, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Powerdown__Soft_reset, 0x01, Bus_NoRead);

        /* Read all bytes */
        err = iTDA18275_ReadRegMap(pObj, 0x00, TDA18275_REG_MAP_NB_BYTES);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_ReadRegMap(0x%08X) failed.", tUnit));
    }
    if (err==TM_OK)
    {
        /* check POR status */
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_Power_state_byte_1__POR , &uVal, Bus_None);
        err = (uVal == 1 ?  TM_OK : TDA18275_ERR_NOT_INITIALIZED);
    }
    /* POR override */
    if(err == TM_OK)
    {
        /* Inform that init phase has started */
        pObj->eHwState = TDA18275_HwState_InitPending;
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Ovld_Udld_byte__Ovld_Disable, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_RSSI_byte_2__RSSI_AV, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_1__PSM_LoMixer, TDA18275_PSM_LoMixer_3_mA, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_2__Loch_curr_boost, TDA18275_Loch_curr_boost_0, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__PSM_Lodriver, TDA18275_PSM_Lodriver_n6_mA, Bus_None);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__PSM_Mixer, TDA18275_PSM_Mixer_n3_mA, Bus_None);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__LOdiv4_Boost, TDA18275_LOdiv4_Boost_0_mA, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
    }

	if(err == TM_OK)
	{
		err = iTDA18275_Write(pObj, &gTDA18275_Reg_RC_Cal_byte_1__RC_Cal_Offset, TDA18275_RC_Cal_Offset, Bus_NoRead);
		tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
	}
	if(err == TM_OK)
	{
		err = iTDA18275_Write(pObj, &gTDA18275_Reg_Regulators_byte__VCO_Reg, TDA18275_VCO_Reg_3_V, Bus_NoRead);
		tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
	}
	if(err == TM_OK)
	{
		err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGCK_byte_1__AGC2_Gain_Control_En, 0x00, Bus_NoRead);
		tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
	}
	if(err == TM_OK)
	{
		err = iTDA18275_Write(pObj, &gTDA18275_Reg_RF_byte__PLD_CC_Enable, 0x00, Bus_NoRead);
		tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
	}
    if(err == TM_OK)
    {
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_ID_byte_3__Minor_rev, &uMinor, Bus_None );
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_ID_byte_3__Major_rev, &uMajor, Bus_None );
        err = iTDA18275_GetIdentity(pObj, &uIdentity);
        if (uIdentity== TDA18275_Identity && uMajor==1 && (uMinor <= 2 || uMinor==4))
        { /* coding inverted in ES1a, ES1b, ES1c, ES1a_MF */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_IR_Cal_byte_4__ircal_boost, TDA18275_ircal_boost_0, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_IR_Cal_byte_3__IR_ROM_offset, TDA18275_IR_ROM_offset_3, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
        }
        else
        {   /* normal coding in other versions ES1' and further */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_IR_Cal_byte_3__IR_ROM_offset, TDA18275_IR_ROM_offset_2, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
	        if(err == TM_OK)
	        {
                /* Set LPFc Offset */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_Byte_1__IF_LPF_Offset, TDA18275_IF_LPF_Offset_12, Bus_None);

                /* Set LPF Offset sign */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_Byte_1__IF_LPF_sign, TDA18275_IF_LPF_sign_Negative, Bus_NoRead);
	        }
	        if(err == TM_OK)
	        {
                /* Set HP Offset  */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_Byte_2__IF_HPF_Offset, TDA18275_IF_HPF_Offset_12, Bus_None);

                /* Set HP Offset sign  */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_IF_Byte_2__IF_HPF_sign, TDA18275_IF_HPF_sign_Negative, Bus_NoRead);
            }
        }
    }
	if(err == TM_OK)
	{
		err = iTDA18275_Write(pObj, &gTDA18275_Reg_Power_Down_byte_1__PD_SUBLO, 0x01, Bus_NoRead);
		tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
	}

    /* set tuner in dedicated internal power state  for calibration */
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Power_state_byte_2__power_state_mode, 0x03, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
    }

    /* Launch RCAL & IR calibration */
    if(err == TM_OK)
    {
        err = iTDA18275_MSMLaunch(pObj, TDA18275_MSM_IR_CAL_Image|TDA18275_MSM_IR_Cal_Loop|TDA18275_MSM_RC_Cal);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_SetMSM(0x%08X, TDA18275_MSM_HwInit) failed.", pObj->tUnitW));
    }

    if(err == TM_OK)
    {
        /* State reached after 300 ms max ( include XTAL cal end */
        err = iTDA18275_WaitIRQ(pObj, 300, 10);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_WaitIRQ(0x%08X) failed.", tUnit));
    }
    /* get RCAL result memory for SETRF */
    if(err == TM_OK)
    {
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_RC_Cal_byte_2__RCcal, &uVal, Bus_NoWrite);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }

    /* launch VCO measurements Max/min */
    if(err == TM_OK)
    {
        err = iTDA18275_ReadallFVCO(pObj);
    }

    /* restore some settings after calibration  */
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_SigmaDelta_Test_byte__LOSD_Static_N, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
    }
	if(err == TM_OK)
	{
		err = iTDA18275_Write(pObj, &gTDA18275_Reg_Power_Down_byte_1__PD_SUBLO, 0x00, Bus_NoRead);
		tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
	}

    /* set tuner POR state:  Sdtby + Xtout */
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Power_state_byte_2__power_state_mode, TDA18275_PowerStandbyWithXtalOn, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", tUnit));
    }
    if(err == TM_OK)
    {
        pObj->curLLPowerState = TDA18275_PowerStandbyWithXtalOn;
        pObj->curPowerState = tmPowerStandby;
    }
    _MUTEX_RELEASE(TDA18275)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_GetIF:                                          */
/*                                                                            */
/* DESCRIPTION: Gets programmed IF.                                           */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_GetIF(
    tmUnitSelect_t  tUnit,  /* I: Unit number */
    UInt32*         puIF    /* O: IF Frequency in hertz */
)
{
    pTDA18275Object_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA18275_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA18275)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA18275_GetIF(0x%08X)", tUnit);

    /* Test parameter(s) */
    if(   pObj->StandardMode<=TDA18275_StandardMode_Unknown
        || pObj->StandardMode>=TDA18275_StandardMode_Max
        || pObj->pStandard == Null
        || puIF == Null)
    {
        err = TDA18275_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        *puIF = pObj->uLO - pObj->uRF;
    }

    _MUTEX_RELEASE(TDA18275)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_GetLockStatus:                                  */
/*                                                                            */
/* DESCRIPTION: Gets PLL Lock Status.                                         */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_GetLockStatus(
    tmUnitSelect_t          tUnit,      /* I: Unit number */
    tmbslFrontEndState_t*   pLockStatus /* O: PLL Lock status */
)
{
    pTDA18275Object_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;
    UInt8               uValue = 0, uValueLO = 0;

    /* Get a driver instance */
    err = iTDA18275_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA18275)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA18275_GetLockStatus(0x%08X)", tUnit);

    if( pLockStatus == Null )
    {
        err = TDA18275_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_Power_state_byte_1__LO_Lock, &uValueLO, Bus_RW);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Read(0x%08X) failed.", pObj->tUnitW));

        if(err == TM_OK)
        {
            err = iTDA18275_Read(pObj, &gTDA18275_Reg_IRQ_status__IRQ_status, &uValue, Bus_RW);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Read(0x%08X) failed.", pObj->tUnitW));
        }

        if(err == TM_OK)
        {
            uValue = uValue & uValueLO;

            *pLockStatus =  (uValue)? tmbslFrontEndStateLocked : tmbslFrontEndStateNotLocked;
        }
        else
        {
            *pLockStatus = tmbslFrontEndStateUnknown;
        }
    }

    _MUTEX_RELEASE(TDA18275)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_GetPowerLevel:                                  */
/*                                                                            */
/* DESCRIPTION: Gets HW Power Level.   1/2 steps dBuV                         */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_GetPowerLevel
(
    tmUnitSelect_t  tUnit,      /* I: Unit number */
    UInt8*          pPowerLevel /* O: Power Level in 1/2 steps dBuV */
)
{
    pTDA18275Object_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;
    UInt8  det6 = 0, Val = 0, uIndex = 0;
    Int32 AGC4_gain_map[5] = {-116289622, -87783305, -58626150, -29563930, 0};
    Int32 AGC5_gain_map[8] = {-207611568, -178962886, -147921117, -118669104, -88630651, -59249802, -29794363, 0};
    Int32 iRF=0;
    Int32 atten_max=0, atten_agc1=0, atten_agc2=0, atten_agc4=0, atten_agc5=0, atten_hpf=0;
    Int32 TDA18275_AGC2_Highpass_gain_map[5][5] =  /* HPF index / RF index */
    {
      {-105490418,	-62334290,	-19015503,	-6528321,	223693},
      {-80109253,	-40654526,	-7992631,	-1037217,	1504974},
      {-51453782,	-19889985,	-549088,	2013397,	2155761},
      {-27699662,	-7179108,	1240615,	1159210,	1443939},
      {0, 0, 0, 0, 0}
    };

    /* Get a driver instance */
    err = iTDA18275_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA18275)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA18275_GetPowerLevel_Calibrated(0x%08X)", tUnit);

    /* Test parameter(s) */
    if( pPowerLevel == Null ||
        pObj->StandardMode<=TDA18275_StandardMode_Unknown ||
        pObj->StandardMode>=TDA18275_StandardMode_Max ||
        pObj->pStandard == Null)
    {
        err = TDA18275_ERR_BAD_PARAMETER;
    }
    if(err == TM_OK)
    {
        /* Read Power Level 1/2 dB */
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_Power_Level_byte_1__Det6_level, &det6, Bus_RW);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Read(0x%08X) failed.", tUnit));
    }

    /* MaxGain(freq) contribution */
    if(err == TM_OK)
    {
        iRF=pObj->uRF/1000000;
        while ( (UInt32)iRF > (TDA18275_max_gain_map[uIndex].RF )  && uIndex < 5)
            uIndex = uIndex + 1;
        if (pObj->uLUCodeProgrammed==0)  /* all pass RPF */
        {
            atten_max = TDA18275_max_gain_map_all_pass[uIndex-1].eq.x0  +  (TDA18275_max_gain_map_all_pass[uIndex-1].eq.x1 * iRF)  + (TDA18275_max_gain_map_all_pass[uIndex-1].eq.x2 / 10 * iRF * iRF);
        }
        else
        {
            atten_max = TDA18275_max_gain_map[uIndex-1].eq.x0  +  (TDA18275_max_gain_map[uIndex-1].eq.x1 * iRF)  + (TDA18275_max_gain_map[uIndex-1].eq.x2 / 10 * iRF * iRF);
        }
    }

    /* AGC1(freq) contribution */
    if(err == TM_OK)
    {
	    err =  iTDA18275_Read(pObj, &gTDA18275_Reg_AGC1_Gain_byte__AGC1_Gain_Read, &Val, Bus_NoWrite);
    }
    if(err == TM_OK)
    {
        atten_agc1 = TDA18275_AGC1_gain_map[Val].x0 +  (TDA18275_AGC1_gain_map[Val].x1 * iRF) + ((TDA18275_AGC1_gain_map[Val].x2 * iRF * iRF)/10);
    }

    /* AGC2(freq) contribution */
    if(err == TM_OK)
    {
	    err =  iTDA18275_Read(pObj, &gTDA18275_Reg_AGC2_Gain_byte__AGC2_Gain_Read, &Val, Bus_NoWrite);
    }
    if(err == TM_OK)
    {
        atten_agc2 = TDA18275_AGC2_gain_map[Val].x0 + (TDA18275_AGC2_gain_map[Val].x1 * iRF) + ((TDA18275_AGC2_gain_map[Val].x2 * iRF * iRF)/10);
    }

    /* AGC4(freq) contribution */
    if(err == TM_OK)
    {
	    err =  iTDA18275_Read(pObj, &gTDA18275_Reg_IFAGCs_Gain_byte__AGC4_Gain_Read, &Val, Bus_NoWrite);
    }
    if(err == TM_OK)
    {
        atten_agc4 = AGC4_gain_map[(Val>4)? 4:Val];
    }

    /* AGC5(freq) contribution */
    if(err == TM_OK)
    {
	    err =  iTDA18275_Read(pObj, &gTDA18275_Reg_IFAGCs_Gain_byte__AGC5_Gain_Read, &Val, Bus_None);
        atten_agc5 = AGC5_gain_map[Val];
    }

    /* AGC2_Highpass(freq) contribution */
    if(err == TM_OK)
    {
	    err =  iTDA18275_Read(pObj, &gTDA18275_Reg_RF_Filters_byte_1__AGC2_Highpass, &Val, Bus_NoWrite);
    }
    if(err == TM_OK)
    {
        if (iRF< 180)
        {
            atten_hpf = TDA18275_AGC2_Highpass_gain_map[Val][0] + ((TDA18275_AGC2_Highpass_gain_map[Val][1] - TDA18275_AGC2_Highpass_gain_map[Val][0]) * (iRF - 100) / 80 );
        }
        else if (iRF< 400)
        {
            atten_hpf = TDA18275_AGC2_Highpass_gain_map[Val][1] + ((TDA18275_AGC2_Highpass_gain_map[Val][2] - TDA18275_AGC2_Highpass_gain_map[Val][1]) / 220 * (iRF - 180));
        }
        else if (iRF< 600)
        {
            atten_hpf = TDA18275_AGC2_Highpass_gain_map[Val][2] + ((TDA18275_AGC2_Highpass_gain_map[Val][3] - TDA18275_AGC2_Highpass_gain_map[Val][2]) / 200 * (iRF - 400));
        }
        else
        {
            atten_hpf = TDA18275_AGC2_Highpass_gain_map[Val][3] + ((TDA18275_AGC2_Highpass_gain_map[Val][4] - TDA18275_AGC2_Highpass_gain_map[Val][3]) / 400 * (iRF - 600));
        }
    }
    atten_max = atten_max + atten_agc1 + atten_agc2 + atten_agc4 + atten_agc5 + atten_hpf;
    atten_max = atten_max /5000000;  /* 1/2 dB 10^7 */

    *pPowerLevel = (UInt8)(det6 - atten_max);

    _MUTEX_RELEASE(TDA18275)

    return err;
}
/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_GetThermo:                                      */
/*                                                                            */
/* DESCRIPTION: returns IC temperature in  C                                 */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_GetThermo(
    tmUnitSelect_t  tUnit,      /* I: Unit number */
    UInt8*          pThermo     /* O: temperature in C */
)
{
    pTDA18275Object_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA18275_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA18275)
    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA18275_GetThermo(0x%08X)", tUnit);

    err = iTDA18275_ReadThermo(pObj, pThermo);
    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_ReadThermo(0x%08X) failed.", pObj->tUnitW));

    _MUTEX_RELEASE(TDA18275)

    return err;
}
/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_SetFineRF:                                      */
/*                                                                            */
/* DESCRIPTION: Fine tunes RF with given step.                                */
/*              (tmbslTDA18275_SetRF must be called before calling this API)  */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_SetFineRF(
    tmUnitSelect_t  tUnit,  /* I: Unit number */
    Int8            step    /* I: step (-1, +1) */
)
{
    pTDA18275Object_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    UInt8 i = 0;
    UInt8 uLoChain_ratio=0;

    /* Get a driver instance */
    err = iTDA18275_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA18275)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA18275_SetFineRF(0x%08X)", tUnit);

    /* Test parameter(s) */
    if(   pObj->StandardMode<=TDA18275_StandardMode_Unknown
        || pObj->StandardMode>=TDA18275_StandardMode_Max
        || pObj->pStandard == Null)
    {
        err = TDA18275_ERR_STD_NOT_SET;
    }

    if(err == TM_OK)
    {
        /* Check if Hw is ready to operate */
        err = iTDA18275_CheckHwState(pObj, TDA18275_HwStateCaller_SetFineRF);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_CheckHwState(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_LoChain_byte__LoChain_ratio, &uLoChain_ratio, Bus_None);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }

    if(err == TM_OK)
    {
        /* Write the offset into 4 equal steps of 15.625 KHz = 62.5 KHz*/
        for (i=0; i < 4; i++)
        {
            /* Calculate wanted LO = RF + IF and FVCO */
            pObj->uRF += step*15625;
            pObj->uFVCO = (pObj->uFVCO/(pObj->uLO /1000)) * ((pObj->uLO + step*15625)/1000) ;
            pObj->uLO += step*15625;

            /* Calculate N & K values of the PLL */
            err = iTDA18275_SetPLL(pObj);
        }

        /* Update driver state machine */
        pObj->eHwState = TDA18275_HwState_SetFineRFDone;
    }

    _MUTEX_RELEASE(TDA18275)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_Write                                           */
/*                                                                            */
/* DESCRIPTION: Writes in TDA18275 hardware                                   */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_Write(
    tmUnitSelect_t              tUnit,      /* I: Unit number */
    const TDA18275_BitField_t*  pBitField,  /* I: Bitfield structure */
    UInt8                       uData,      /* I: Data to write */
    tmbslFrontEndBusAccess_t                eBusAccess  /* I: Access to bus */
)
{
    pTDA18275Object_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA18275_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA18275)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA18275_Write(0x%08X)", tUnit);

    err = iTDA18275_Write(pObj, pBitField, uData, eBusAccess);
    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));

    _MUTEX_RELEASE(TDA18275)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_Read                                            */
/*                                                                            */
/* DESCRIPTION: Reads in TDA18275 hardware                                    */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA18275_Read(
    tmUnitSelect_t              tUnit,      /* I: Unit number */
    const TDA18275_BitField_t*  pBitField,  /* I: Bitfield structure */
    UInt8*                      puData,     /* I: Data to read */
    tmbslFrontEndBusAccess_t                eBusAccess  /* I: Access to bus */
)
{
    pTDA18275Object_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA18275_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA18275)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA18275_Read(0x%08X)", tUnit);

    err = iTDA18275_Read(pObj, pBitField, puData, eBusAccess);
    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Read(0x%08X) failed.", pObj->tUnitW));

    _MUTEX_RELEASE(TDA18275)

    return err;
}

/*============================================================================*/
/* Internal functions:                                                        */
/*============================================================================*/

/*============================================================================*/
/* FUNCTION:    iTDA18275_CheckHwState                                        */
/*                                                                            */
/* DESCRIPTION: Checks if Hw is ready to operate.                             */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA18275_CheckHwState(
    pTDA18275Object_t       pObj,   /* I: Driver object */
    TDA18275HwStateCaller_t caller  /* I: Caller API */
)
{
    tmErrorCode_t   err = TM_OK;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_CheckHwState(0x%08X)", pObj->tUnitW);

    switch(pObj->eHwState)
    {
        case TDA18275_HwState_InitNotDone:
            switch(caller)
            {
                case TDA18275_HwStateCaller_SetPower:
                    break;

                default:
                    err = TDA18275_ERR_NOT_INITIALIZED;
                    break;
            }
            break;

        case TDA18275_HwState_InitDone:
            switch(caller)
            {
                case TDA18275_HwStateCaller_SetRF:
                case TDA18275_HwStateCaller_SetFineRF:
                    /* SetStandardMode API must be called before calling SetRF and SetFineRF */
                    err = TDA18275_ERR_STD_NOT_SET;
                    break;

                default:
                    break;
            }
            break;

        case TDA18275_HwState_SetStdDone:
            switch(caller)
            {
                case TDA18275_HwStateCaller_SetFineRF:
                    /* SetRF API must be called before calling SetFineRF */
                    err = TDA18275_ERR_RF_NOT_SET;
                    break;

                default:
                    break;
            }
            break;

        case TDA18275_HwState_SetRFDone:
        case TDA18275_HwState_SetFineRFDone:
            break;

        case TDA18275_HwState_InitPending:
            err = TDA18275_ERR_NOT_READY;
            break;
        default:
            err = TDA18275_ERR_NOT_READY;
            break;
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA18275_SetLLPowerState                                     */
/*                                                                            */
/* DESCRIPTION: Sets the power state.                                         */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA18275_SetLLPowerState(
    pTDA18275Object_t       pObj,       /* I: Driver object */
    TDA18275PowerState_t    powerState  /* I: Power state of TDA18275 */
)
{
    tmErrorCode_t   err = TM_OK;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_SetLLPowerState(0x%08X)", pObj->tUnitW);

    if (pObj->curLLPowerState != powerState)
    {

        if(err == TM_OK)
        {
            switch(powerState)
            {
            case TDA18275_PowerNormalMode:
                    err = iTDA18275_Write(pObj, &gTDA18275_Reg_Power_state_byte_2__power_state_mode, powerState, Bus_NoRead);
                    if(err == TM_OK)
                    {
                        /* disable HighZ LNA */
                        err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC1_byte_1__LNA_HiZ, 0x00, Bus_NoRead);
                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
                    }
                break;
            default: /* all standby modes */
                    /* enable HighZ LNA */
                    err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC1_byte_1__LNA_HiZ, 0x01, Bus_NoRead);
                    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));

                    if(err == TM_OK)
                    {
                        /* Set digital clock mode to 16 Mhz before entering standby */
                        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Reference_Byte__Dig_Clock, TDA18275_Dig_Clock_16MHz, Bus_NoRead);
                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
                    }
                    if(err == TM_OK)
                    {
                        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Power_state_byte_2__power_state_mode, powerState, Bus_NoRead);
                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
                    }
                break;
            }
        }

        if(err == TM_OK)
        {
            /* Store low-level power state in driver instance */
            pObj->curLLPowerState = powerState;
        }
    }

    return err;
}
/*============================================================================*/
/* FUNCTION:    iTDA18275_ReadThermo:                                         */
/*                                                                            */
/* DESCRIPTION: activate & read Thermo                                        */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
static tmErrorCode_t
iTDA18275_ReadThermo(
    pTDA18275Object_t   pObj,    /* I: Driver object */
    UInt8*            puThermo  /* O: temperature read */
    )
{
    tmErrorCode_t   err = TM_OK;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_ReadThermo(0x%08X)", pObj->tUnitW);

    err = iTDA18275_Write(pObj, &gTDA18275_Reg_Thermo_byte_2__TM_ON, 0x01, Bus_NoRead );
    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    if(err == TM_OK)
    {
        err = iTDA18275_Read(pObj,&gTDA18275_Reg_Thermo_byte_1__TM_D, puThermo, Bus_NoWrite);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Read(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Thermo_byte_2__TM_ON, 0x00, Bus_NoRead );
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }

    return err;
}
/*============================================================================*/
/* FUNCTION:    iTDA18275_ReadFVCO   :                                        */
/*                                                                            */
/* DESCRIPTION: launch all VCO measure                                        */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
static tmErrorCode_t
iTDA18275_ReadallFVCO(
    pTDA18275Object_t   pObj    /* I: Driver object */
    )
{
    tmErrorCode_t   err = TM_OK;

    /* default typical VCO limits T amb 60  */
    pObj->VCO[2].fmin = TDA18275_VCO_LOW_MIN;
    pObj->VCO[2].fmax = TDA18275_VCO_LOW_MAX;
    pObj->VCO[1].fmin = TDA18275_VCO_MED_MIN;
    pObj->VCO[1].fmax = TDA18275_VCO_MED_MAX;
    pObj->VCO[0].fmin = TDA18275_VCO_HIGH_MIN;
    pObj->VCO[0].fmax = TDA18275_VCO_HIGH_MAX;

    /* Settings for Fvco measurements */

    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Charge_pump_byte__cp_cursel, 0x07, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Sigma_delta_byte_1__LO_Int, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }


    /***** VCO High fmax measurement **********/
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Charge_pump_byte__ICP_Force_Src, 0x01, Bus_None );
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Charge_pump_byte__ICP_Force_Sink, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_LoChain_byte__PLL_Div2_Highfreq, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.",  pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Sigma_prog_byte__Update_prg, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
        err = err | iTDA18275_Write(pObj, &gTDA18275_Reg_Sigma_prog_byte__Update_prg, 0x00, Bus_None);
    }

    if(err == TM_OK)
    {
        err = iTDA18275_ReadFVCO(pObj, 0, 0);  /* VCO high , Freq max */
    }

    /***** VCO Mid fmax measurement **********/
    if(err == TM_OK)
    {
        err = iTDA18275_ReadFVCO(pObj, 1, 0);  /* VCO Med , Freq max */
    }

    /***** VCO High fmin measurement **********/
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Charge_pump_byte__ICP_Force_Src, 0x00, Bus_None );
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Charge_pump_byte__ICP_Force_Sink, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.",  pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_LoChain_byte__PLL_Div2_Highfreq, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.",  pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Sigma_prog_byte__Update_prg, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
        err = err | iTDA18275_Write(pObj, &gTDA18275_Reg_Sigma_prog_byte__Update_prg, 0x00, Bus_None);
    }

    if(err == TM_OK)
    {
        err = iTDA18275_ReadFVCO(pObj, 0, 1);  /* VCO high , Freq min */
    }

    /***** VCO Mid fmin measurement **********/
    if(err == TM_OK)
    {
        err = iTDA18275_ReadFVCO(pObj, 1, 1);  /* VCO Med , Freq min */
    }

    /***** VCO Low fmin measurement **********/
    if(err == TM_OK)
    {
        err = iTDA18275_ReadFVCO(pObj, 2, 1);  /* VCO low , Freq min */
    }

    /***** VCO Low fmax measurement **********/
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Charge_pump_byte__ICP_Force_Src, 0x01, Bus_None );
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Charge_pump_byte__ICP_Force_Sink, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.",  pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_ReadFVCO(pObj, 2, 0);  /* VCO low , Freq max */
    }

    /* restore ICP params */
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Charge_pump_byte__ICP_Force_Src, 0x00, Bus_None );
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Charge_pump_byte__ICP_Force_Sink, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.",  pObj->tUnitW));
    }

    if(err == TM_OK)
    {
        err = iTDA18275_ReadThermo(pObj, &pObj->Temp_Meas);
    }
    return err;
}
/*============================================================================*/
/* FUNCTION:    iTDA18275_ReadFVCO   :     i : VCO number, i: 0 max 1 min     */
/*                                                                            */
/* DESCRIPTION: launch VCO measure and store                                  */
/*             store in pObj->VCO[i].fmax & fmin                              */
/*                                                                            */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
static tmErrorCode_t
iTDA18275_ReadFVCO(
    pTDA18275Object_t   pObj,    /* I: Driver object */
    UInt8            VCOnum,  /* I: VCO index */
    UInt8            VCOfreq   /* 0: max  1: min */
    )
{
    tmErrorCode_t   err = TM_OK;
    UInt8 uVal=0;
    UInt32 FreqVal = 0, FreqRef = 0, FreqRatio = 0;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_ReadFVCO(0x%08X)", pObj->tUnitW);

    if(err == TM_OK)
    {
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_VCO_byte__VCO_Select, &uVal, Bus_None);
        if (uVal != VCOnum) err = iTDA18275_Write(pObj, &gTDA18275_Reg_VCO_byte__VCO_Select, VCOnum, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }

    /* Set state machine and Launch it */
    err = iTDA18275_MSMLaunch(pObj, TDA18275_MSM_VCO_Freq_Meas);
    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_MSMLaunch(0x%08X, TDA18275_MSM_VCO_Freq) failed.", pObj->tUnitW));

    if(err == TM_OK)
    {
        /* State reached after 10 ms max */
        err = iTDA18275_WaitIRQ(pObj, 10, 1);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_WaitIRQ(0x%08X) failed.",  pObj->tUnitW));
    }
    /* read & store measured freq */
    if(err == TM_OK)
    {
        err = iTDA18275_ReadRegMap(pObj, gTDA18275_Reg_FVCO_MAX_BYTE_1__FVCO_max_1.Address, 0x03);
    }
    if(err == TM_OK)
    {
        /* Value read  over 24 bits equal to frequence in Khz divided by 4 */
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_FVCO_MAX_BYTE_1__FVCO_max_1, &uVal, Bus_None);
        FreqVal = uVal << 16;
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_FVCO_MAX_BYTE_2__FVCO_max_2, &uVal, Bus_None);
        FreqVal = FreqVal + (uVal <<8);
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_FVCO_MAX_BYTE_3__FVCO_max_3, &uVal, Bus_None);
        FreqVal = (FreqVal + uVal) * 4;  /* convert from Khz/4 to Khz */
        FreqRef = (VCOfreq==0)? pObj->VCO[VCOnum].fmax : pObj->VCO[VCOnum].fmin;
        /* check read Value not over 20%  typical VCO limits */
        FreqRatio = (FreqVal>FreqRef)? FreqVal*10 / FreqRef : FreqRef*10 /FreqVal  ;
        if (VCOfreq==0 && FreqRatio < 12)
        {
            pObj->VCO[VCOnum].fmax  = FreqVal;
        }
        else if (FreqRatio < 12)
        {
            pObj->VCO[VCOnum].fmin  = FreqVal;
        }
    }

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_ReadFVCO(0x%08X)", pObj->tUnitW);
    return err;
}


/*============================================================================*/
/* FUNCTION:    iTDA18275_VCOselection:                                       */
/*                                                                            */
/* DESCRIPTION: Choose VCO fct ( Termo + LO ( RF + IF )                       */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
static tmErrorCode_t
iTDA18275_VCOselection(
    pTDA18275Object_t   pObj    /* I: Driver object */
    )
{
    tmErrorCode_t   err = TM_OK;
    UInt8 NLOi=0, NLOsup=0, VCOnum=0,VCOsup=0, VCOinf=0, VCOi=0;
    Int8 NLOinf=0;
    Int32 VCOsupmarginup=0, VCOinfmarginup=0, VCOsupmargindown=0,VCOinfmargindown=0,FCVO_marge_MFT_inf=0, FCVO_marge_MFT_sup=0;
    UInt32 LO=0, FCVOsup=0, FCVOinf=0; /* calcl in Khz */
    UInt8 NLOtab[9] = { 8, 12, 16, 24, 32, 48, 64, 96, 128 };
    UInt32 diffupfreq[3]={0, 0, 0}, diffdofreq[3]={0, 0, 0} ;
    UInt32 FreqWIFI5G = 5855000;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_VCOselection(0x%08X)", pObj->tUnitW);


    LO = pObj->uLO / 1000;  /* in Khz */
    tmDBGPRINTEx(DEBUGLVL_TERSE, ";LO ; NLOinf; FVCOinf;  VCOinf ;Mup ; Mdo ;  NLOsup; FCVOsup;  VCOsup; Mup  ; Mdo ;->; FCVO;  VCO;   NLO; MarUp ; MargDo " );

    /* search  NLO sup */
    NLOsup = 9;
    do
    {
       NLOsup = NLOsup - 1;
    } while ( (UInt32)(NLOtab[NLOsup]*LO) > (UInt32)(pObj->VCO[0].fmax ) &&  NLOsup > 0 );

    /* search  NLO inf */
    NLOinf = -1;
    do
    {
       NLOinf = NLOinf + 1;
    } while ( (UInt32)(NLOtab[NLOinf]*LO) < FreqWIFI5G && NLOinf < 8 );

    /* calculate potential drift in T?up and down */
    for (VCOi=0; VCOi<3; VCOi++)
    {
        diffupfreq[VCOi] = pObj->VCO[VCOi].fmax / 6622 * 3  * pObj->Temp_Meas; /* T?decrease to 0?*/
        diffdofreq[VCOi] = pObj->VCO[VCOi].fmax / 6622 * 3  * (125 - pObj->Temp_Meas); /* T?increase to 125?*/
    }

    /* selection VCO of NLOsup  */
    FCVOsup = NLOtab[NLOsup]*LO;
    FCVO_marge_MFT_sup = (100000+NLOtab[NLOsup]*2000);
    if (FCVOsup > pObj->VCO[TDA18275_VCO_Select_VCO_Medium].fmax)
    {
        VCOsup = TDA18275_VCO_Select_VCO_High;
        VCOsupmarginup = pObj->VCO[TDA18275_VCO_Select_VCO_High].fmax - diffdofreq[TDA18275_VCO_Select_VCO_High] - FCVOsup;
        VCOsupmargindown = FCVOsup - pObj->VCO[TDA18275_VCO_Select_VCO_High].fmin - diffupfreq[TDA18275_VCO_Select_VCO_High];
    }
    else if (FCVOsup > pObj->VCO[TDA18275_VCO_Select_VCO_High].fmin)
    { /* H & M decision */
        VCOsupmarginup = pObj->VCO[TDA18275_VCO_Select_VCO_Medium].fmax - diffdofreq[TDA18275_VCO_Select_VCO_Medium] - FCVOsup;
        VCOsupmargindown = FCVOsup - pObj->VCO[TDA18275_VCO_Select_VCO_High].fmin - diffupfreq[TDA18275_VCO_Select_VCO_High];
        if ((VCOsupmarginup>FCVO_marge_MFT_sup) || ( VCOsupmargindown < FCVO_marge_MFT_sup))
        {
           VCOsup = TDA18275_VCO_Select_VCO_Medium;
           VCOsupmargindown = FCVOsup - pObj->VCO[TDA18275_VCO_Select_VCO_Medium].fmin - diffupfreq[TDA18275_VCO_Select_VCO_Medium];
        }
        else
        {
           VCOsup = TDA18275_VCO_Select_VCO_High;
           VCOsupmarginup = pObj->VCO[TDA18275_VCO_Select_VCO_High].fmax - diffdofreq[TDA18275_VCO_Select_VCO_High] - FCVOsup;
        }
    }
    else if (FCVOsup > pObj->VCO[TDA18275_VCO_Select_VCO_Low].fmax)
    {
        VCOsup = TDA18275_VCO_Select_VCO_Medium;
        VCOsupmarginup = pObj->VCO[TDA18275_VCO_Select_VCO_Medium].fmax - diffdofreq[TDA18275_VCO_Select_VCO_Medium] - FCVOsup;
        VCOsupmargindown = FCVOsup - pObj->VCO[TDA18275_VCO_Select_VCO_Medium].fmin - diffupfreq[TDA18275_VCO_Select_VCO_Medium];
    }
    else if (FCVOsup > pObj->VCO[TDA18275_VCO_Select_VCO_Medium].fmin)
    { /* M & L decision */
        VCOsupmarginup = pObj->VCO[TDA18275_VCO_Select_VCO_Low].fmax - diffdofreq[TDA18275_VCO_Select_VCO_Low] - FCVOsup;
        VCOsupmargindown = FCVOsup - pObj->VCO[TDA18275_VCO_Select_VCO_Medium].fmin - diffupfreq[TDA18275_VCO_Select_VCO_Medium];
        if ((VCOsupmarginup>FCVO_marge_MFT_sup) || ( VCOsupmargindown < FCVO_marge_MFT_sup))
        {
            VCOsup = TDA18275_VCO_Select_VCO_Low;
            VCOsupmargindown = FCVOsup - diffupfreq[TDA18275_VCO_Select_VCO_Low];
            VCOsupmargindown = VCOsupmargindown - ( pObj->VCO[TDA18275_VCO_Select_VCO_Low].fmin > FreqWIFI5G ? pObj->VCO[TDA18275_VCO_Select_VCO_Low].fmin:FreqWIFI5G );
        }
        else
        {
           VCOsup = TDA18275_VCO_Select_VCO_Medium;
           VCOsupmarginup = pObj->VCO[TDA18275_VCO_Select_VCO_Medium].fmax - diffdofreq[TDA18275_VCO_Select_VCO_Medium] - FCVOsup;
        }
    }
    else
    {
        VCOsup = TDA18275_VCO_Select_VCO_Low;
        VCOsupmarginup = pObj->VCO[TDA18275_VCO_Select_VCO_Low].fmax - diffdofreq[TDA18275_VCO_Select_VCO_Low] - FCVOsup;
        VCOsupmargindown = pObj->VCO[TDA18275_VCO_Select_VCO_Low].fmin + diffupfreq[TDA18275_VCO_Select_VCO_Low];
        VCOsupmargindown = VCOsupmargindown > (Int32)FreqWIFI5G ? VCOsupmargindown:(Int32)FreqWIFI5G;
        VCOsupmargindown = FCVOsup - VCOsupmargindown;
    }

    if ( NLOinf == NLOsup)
    {
        VCOnum = VCOsup;
        NLOi = NLOsup;
    }
    else
    {
        /* selection VCO of NLOinf  */
        FCVOinf = NLOtab[NLOinf]*LO;
        FCVO_marge_MFT_inf = (100000+NLOtab[NLOinf]*2000);
        if (FCVOinf > pObj->VCO[TDA18275_VCO_Select_VCO_Medium].fmax)
        {
            VCOinf = TDA18275_VCO_Select_VCO_High;
            VCOinfmarginup = pObj->VCO[TDA18275_VCO_Select_VCO_High].fmax - diffdofreq[TDA18275_VCO_Select_VCO_High] - FCVOinf;
            VCOinfmargindown = FCVOinf - pObj->VCO[TDA18275_VCO_Select_VCO_High].fmin - diffupfreq[TDA18275_VCO_Select_VCO_High];
        }
        else if (FCVOinf > pObj->VCO[TDA18275_VCO_Select_VCO_High].fmin)
        { /* H & M decision */
            VCOinfmarginup = pObj->VCO[TDA18275_VCO_Select_VCO_Medium].fmax - diffdofreq[TDA18275_VCO_Select_VCO_Medium] - FCVOinf;
            VCOinfmargindown = FCVOinf - pObj->VCO[TDA18275_VCO_Select_VCO_High].fmin - diffupfreq[TDA18275_VCO_Select_VCO_High];
            if ((VCOinfmarginup>FCVO_marge_MFT_inf) || ( VCOinfmargindown < FCVO_marge_MFT_inf))
            {
               VCOinf = TDA18275_VCO_Select_VCO_Medium;
               VCOinfmargindown = FCVOinf - pObj->VCO[TDA18275_VCO_Select_VCO_Medium].fmin - diffupfreq[TDA18275_VCO_Select_VCO_Medium];
            }
            else
            {
               VCOinf = TDA18275_VCO_Select_VCO_High;
               VCOinfmarginup = pObj->VCO[TDA18275_VCO_Select_VCO_High].fmax - diffdofreq[TDA18275_VCO_Select_VCO_High] - FCVOinf;
            }
        }
        else if (FCVOinf > pObj->VCO[TDA18275_VCO_Select_VCO_Low].fmax)
        {
            VCOinf = TDA18275_VCO_Select_VCO_Medium;
            VCOinfmarginup = pObj->VCO[TDA18275_VCO_Select_VCO_Medium].fmax - diffdofreq[TDA18275_VCO_Select_VCO_Medium] - FCVOinf;
            VCOinfmargindown = FCVOinf - pObj->VCO[TDA18275_VCO_Select_VCO_Medium].fmin - diffupfreq[TDA18275_VCO_Select_VCO_Medium];
        }
        else if (FCVOinf > pObj->VCO[TDA18275_VCO_Select_VCO_Medium].fmin)
        { /* M & L decision */
            VCOinfmarginup = pObj->VCO[TDA18275_VCO_Select_VCO_Low].fmax - diffdofreq[TDA18275_VCO_Select_VCO_Low] - FCVOinf;
            VCOinfmargindown = FCVOinf - pObj->VCO[TDA18275_VCO_Select_VCO_Medium].fmin - diffupfreq[TDA18275_VCO_Select_VCO_Medium];
            if ((VCOinfmarginup>FCVO_marge_MFT_inf) || ( VCOinfmargindown < FCVO_marge_MFT_inf))
            {
                VCOinf = TDA18275_VCO_Select_VCO_Low;
                VCOinfmargindown = FCVOinf - diffupfreq[TDA18275_VCO_Select_VCO_Low];
                VCOinfmargindown = VCOinfmargindown - ( pObj->VCO[TDA18275_VCO_Select_VCO_Low].fmin > FreqWIFI5G ? pObj->VCO[TDA18275_VCO_Select_VCO_Low].fmin:FreqWIFI5G );
            }
            else
            {
               VCOinf = TDA18275_VCO_Select_VCO_Medium;
               VCOinfmarginup = pObj->VCO[TDA18275_VCO_Select_VCO_Medium].fmax - diffdofreq[TDA18275_VCO_Select_VCO_Medium] - FCVOinf;
            }
        }
        else
        {
            VCOinf = TDA18275_VCO_Select_VCO_Low;
            VCOinfmarginup = pObj->VCO[TDA18275_VCO_Select_VCO_Low].fmax - diffdofreq[TDA18275_VCO_Select_VCO_Low] - FCVOinf;
            VCOinfmargindown = pObj->VCO[TDA18275_VCO_Select_VCO_Low].fmin + diffupfreq[TDA18275_VCO_Select_VCO_Low];
            VCOinfmargindown = VCOinfmargindown > (Int32)FreqWIFI5G ? VCOinfmargindown:(Int32)FreqWIFI5G;
            VCOinfmargindown = FCVOinf - VCOinfmargindown;
        }

         /* choose best VCO either FCVOinf or FCVOsup */
         if((VCOsupmarginup>FCVO_marge_MFT_sup) && (VCOsupmargindown>FCVO_marge_MFT_sup)) /* FCVO in upper part of VCO */
         {
             VCOnum = VCOsup;
             NLOi = NLOsup;
         }
         else if((VCOinfmarginup>FCVO_marge_MFT_inf) && (VCOinfmargindown>FCVO_marge_MFT_inf))
         {
             VCOnum = VCOinf;
             NLOi = NLOinf;
         }
         else
         {
             /* eliminate VCO choice with lowest margin either up or down */
             if (VCOinfmargindown < VCOinfmarginup)
             {
                if(VCOinfmargindown < VCOsupmargindown)
                {
                    if(VCOinfmargindown < VCOsupmarginup)
                    {
                        VCOnum = VCOsup;
                        NLOi = NLOsup;
                    }
                    else
                    {
                        VCOnum = VCOinf;
                        NLOi = NLOinf;
                    }
                }
                else
                {
                    VCOnum = VCOinf;
                    NLOi = NLOinf;
                }
             }
             else
             {
                if(VCOinfmarginup < VCOsupmargindown)
                {
                    if(VCOinfmarginup < VCOsupmarginup)
                    {
                        VCOnum = VCOsup;
                        NLOi = NLOsup;
                    }
                    else
                    {
                        VCOnum = VCOinf;
                        NLOi = NLOinf;
                    }
                }
                else
                {
                    VCOnum = VCOinf;
                    NLOi = NLOinf;
                }
             }
         }
     }

    pObj->uFVCO = NLOtab[NLOi]*LO ;

    /* Write VCO selection */
    err = iTDA18275_Write(pObj, &gTDA18275_Reg_VCO_byte__VCO_Select, VCOnum, Bus_NoRead);
    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));


    tmDBGPRINTEx(DEBUGLVL_TERSE, ";%d;  %d ; %d; %d  ;%d ;%d;  %d ; %d;  %d  ;%d ; %d ; -> ; %d;  %d; %d ; %d ; %d", \
        LO, (NLOinf==NLOsup ? 0 : NLOtab[NLOinf]), (NLOinf==NLOsup ? 0 : (NLOtab[NLOinf]*LO)), (NLOinf==NLOsup ? 0 : VCOinf), (NLOinf==NLOsup ? 0 :VCOinfmarginup), (NLOinf==NLOsup ? 0 :VCOinfmargindown), \
        NLOtab[NLOsup], (NLOtab[NLOsup]*LO), VCOsup, VCOsupmarginup, VCOsupmargindown, \
        pObj->uFVCO, VCOnum,  NLOtab[NLOi], ( (NLOi==NLOsup) ? VCOsupmarginup : VCOinfmarginup ), ( (NLOi==NLOsup) ? VCOsupmargindown : VCOinfmargindown ));

    if (err == TM_OK)
    {
        /* Write LoChain_ratio with decoding as below  */
        /*  NLOtab = { 8, 12, 16, 24, 32, 48, 64, 96, 128 };
      LO chain ration  2  3   4   6    8  12  16  24  32
          value I2C     0  1   2   3    8   9  10  11  12  */

        err = iTDA18275_Write(pObj, &gTDA18275_Reg_LoChain_byte__LoChain_ratio, (NLOi<4?NLOi:NLOi+4), Bus_None);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));

        /* adapt PLL_Div2_Highfreq vs FVCO 8Ghz limit*/
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_LoChain_byte__PLL_Div2_Highfreq, (pObj->uFVCO > 8000000 ? 0x01 : 0x00), Bus_NoRead);
    }

    return err;

}

/*============================================================================*/
/* FUNCTION:    iTDA18275_SetRF:                                              */
/*                                                                            */
/* DESCRIPTION: Tunes to a RF.                                                */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA18275_SetRF(
    pTDA18275Object_t   pObj    /* I: Driver object */
)
{
    tmErrorCode_t   err = TM_OK;

    err = iTDA18275_SetRF_NoFast(pObj);

    /* force Gains to max  */
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_RF_byte__AGCs_loop_off, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC2_byte_2__AGC2_Gain, 141, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
         err = iTDA18275_Write(pObj, &gTDA18275_Reg_RF_byte__Force_AGC2_gain, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_IR_Mixer_byte_2__Force_AGC4_gain, 0x01, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_IR_Mixer_byte_2__AGC4_Gain, 4, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC5_byte_2__Force_AGC5_gain, 0x01, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC5_byte_2__AGC5_Gain, 7, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    /* release Gains  */
    if(err == TM_OK)
    {
         err = iTDA18275_Write(pObj, &gTDA18275_Reg_RF_byte__Force_AGC2_gain, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_IR_Mixer_byte_2__Force_AGC4_gain, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC5_byte_2__Force_AGC5_gain, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_RF_byte__AGCs_loop_off, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }

    /* Launch AGC fast mode */
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_MSM_byte_2__AGC_CC_Fast_Launch, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_MSM_byte_2__AGC_CC_Fast_Launch, 0x00, Bus_None);
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA18275_SetRF:                                              */
/*                                                                            */
/* DESCRIPTION: Tunes to a RF.                                                */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA18275_SetRF_NoFast(
    pTDA18275Object_t   pObj    /* I: Driver object */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt8 uVal=0;

    err = iTDA18275_SetLO(pObj);

    /*  RF filter programmation: RF_LPF & RF-LPF_Feed & IR_FreqPtr */
    if(err == TM_OK)
    {
        err = iTDA18275_SetRF_Freq(pObj);
    }
    /* adapt AGC2 if algo activated */
    if ((pObj->pStandard->HighPass_AGC2_algo == TDA18275_HighPass_AGC2_Digital) ||
        (pObj->pStandard->HighPass_AGC2_algo == TDA18275_HighPass_AGC2_Analog) )
    {
        if (pObj->uRF >= 766000000)
        {
            uVal = TDA18275_AGC2_Highpass_766_MHz;
        }
        else if (pObj->uRF >= 600000000)
        {
            uVal = TDA18275_AGC2_Highpass_600_MHz;
        }
        else if (pObj->uRF >= 470000000)
        {
            uVal = TDA18275_AGC2_Highpass_470_MHz;
        }
        else if (pObj->uRF >= 180000000)
        {
            uVal = TDA18275_AGC2_Highpass_180_MHz;
        }
        else
        {
            uVal = TDA18275_AGC2_Highpass_20_MHz;
        }
    }
    else if (pObj->pStandard->HighPass_AGC2_algo == TDA18275_HighPass_AGC2_Analog_GH)
    {
        if (pObj->uRF >= 600000000)
        {
            uVal = TDA18275_AGC2_Highpass_766_MHz;
        }
        else if (pObj->uRF >= 470000000)
        {
            uVal = TDA18275_AGC2_Highpass_470_MHz;
        }
        else if (pObj->uRF >= 180000000)
        {
            uVal = TDA18275_AGC2_Highpass_180_MHz;
        }
        else
        {
            uVal = TDA18275_AGC2_Highpass_20_MHz;
        }
    }
    else if (pObj->pStandard->HighPass_AGC2_algo == TDA18275_HighPass_AGC2_QAM)
    {
        if (pObj->uRF >= 400000000)
        {
            uVal = TDA18275_AGC2_Highpass_20_MHz;
        }
        else if (pObj->uRF >= 100000000)
        {
            uVal = TDA18275_AGC2_Highpass_470_MHz;
        }
        else
        {
            uVal = TDA18275_AGC2_Highpass_20_MHz;
        }
    }
    else if (pObj->pStandard->HighPass_AGC2_algo == TDA18275_HighPass_AGC2_20MHZ)
    {
        uVal = TDA18275_AGC2_Highpass_20_MHz;
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_RF_Filters_byte_1__AGC2_Highpass, uVal, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }


    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA18275_SetLO:                                              */
/*                                                                            */
/* DESCRIPTION: Tunes to a LO.                                                */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA18275_SetLO(
    pTDA18275Object_t   pObj    /* I: Driver object */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt8 counter=0, uVal=0, uThermo=0, VCOnum=0, VCOnum_new=0;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_SetRF(0x%08X)", pObj->tUnitW);


    if(pObj->curPowerState != tmPowerOn)
    {
        /* Set power state ON */
        err = iTDA18275_SetLLPowerState(pObj, TDA18275_PowerNormalMode);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_SetLLPowerState(0x%08X, PowerNormalMode) failed.", pObj->tUnitW));
    }

    if(err == TM_OK)
    {
        pObj->curPowerState = tmPowerOn;
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Reference_Byte__Dig_Clock, TDA18275_Dig_Clock_16MHz, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
       /* Set cp_cursel */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Charge_pump_byte__cp_cursel, TDA18275_cp_cursel_420_uA , Bus_None);
       /* Set cp_cursel */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Charge_pump_byte__cpleak0, 0x00 , Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
       /* Set VCO_currentctrl */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_VCO_cal_byte_1__VCO_currentctrl, 0x00 , Bus_None);
       /* Set VCOampl_force_cur */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_VCO_cal_byte_1__VCOampl_force_cur, 0x01 , Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }

    /* Read Thermo */
    if(err == TM_OK)
    {
        err = iTDA18275_ReadThermo( pObj, &uThermo );
    }

    /* VCO selection */
    if(err == TM_OK)
    {
        err = iTDA18275_VCOselection(pObj);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_VCOselection(0x%08X) failed.", pObj->tUnitW));
    }

    if(err == TM_OK)
    {
        err = iTDA18275_SetPLL(pObj);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_SetPLL(0x%08X) failed.", pObj->tUnitW));
    }

    /* Wait LO_Lock timeout 20ms */
    counter = 20;
    while(counter > 0)
    {
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_Power_state_byte_1__LO_Lock, &uVal, Bus_NoWrite);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Read(0x%08X) failed.", pObj->tUnitW));
        if(err==TM_OK && uVal==0x01)
        {
            /* PLL Lock */
            break;
        }
        if(counter)
        {
            /* Decrease the counter */
            counter--;

            /* Wait for a step of  1ms */
            err = iTDA18275_Wait(pObj, 1);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Wait(0x%08X) failed.", pObj->tUnitW));
        }
	}
    if (err==TM_OK && counter==0)
    {  /* timeout LO_lock reached */
        err = TDA18275_ERR_NOT_READY;

        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_SetLO(0x%08X) 1st timeout LO_lock reached.", pObj->tUnitW));
    }

    /* Vtune sense and VCO adaptation */
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Power_Down_byte_1__PD_adc_vtune, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_vco_log__adc_vtune, &uVal, Bus_NoWrite);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Power_Down_byte_1__PD_adc_vtune, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    /* adapt VCO swing Ctrl vs adc_vtune */
    if(err == TM_OK)
    {
        err = iTDA18275_Adapt_vco_swingctrl(pObj, uVal, VCOnum_new);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_VCO_cal_byte_1__VCOampl_force_cur, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    /* run VCP amp */
    if(err == TM_OK)
    {
        err = iTDA18275_MSMLaunch(pObj, TDA18275_MSM_VCO_Ampl_Cal);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_SetMSM(0x%08X, TDA18275_MSM_HwInit) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        /* State reached after 10ms max */
        err = iTDA18275_WaitIRQ(pObj, 10, 1);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_WaitIRQ(0x%08X) failed.", pObj->tUnitW));
    }
    /* Vtune sense and VCO adaptation */
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Power_Down_byte_1__PD_adc_vtune, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_vco_log__adc_vtune, &uVal, Bus_NoWrite);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Power_Down_byte_1__PD_adc_vtune, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_VCO_byte__VCO_Select, &VCOnum, Bus_None);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Read(0x%08X) failed.", pObj->tUnitW));
    }

    /* check potential VCO change */
    VCOnum_new = VCOnum;
    if ((err == TM_OK) && (uVal > 5) && (uThermo < 50) && VCOnum!=TDA18275_VCO_Select_VCO_High) /* vt > 1.8v & tj < 50?*/
    {
        /* Choose upper VCO  */
        tmDBGPRINTEx(DEBUGLVL_TERSE,"request upper  VCO  change  %d\n\r");
        /* check VCO capabilities */
        if ( (pObj->VCO[VCOnum-1].fmin <= pObj->uFVCO ) && ( pObj->uFVCO <= pObj->VCO[VCOnum-1].fmax ) )
        {
            VCOnum_new = VCOnum-1;
            tmDBGPRINTEx(DEBUGLVL_TERSE,"Change VCO  sup %d\n\r", VCOnum_new);
        }
    }
    else if ((err == TM_OK) && (uVal < 3 ) && (uThermo > 90 ) && VCOnum!=TDA18275_VCO_Select_VCO_Low) /* vt < 0.3v & tj > 90 */
    {
        /* Choose lower VCO  */
        tmDBGPRINTEx(DEBUGLVL_TERSE,"request lower  VCO  change  %d\n\r");
       /* check VCO capabilities */
        if ( (pObj->VCO[VCOnum+1].fmin <= pObj->uFVCO ) && ( pObj->uFVCO <= pObj->VCO[VCOnum+1].fmax ) )
        {
            VCOnum_new = VCOnum+1;
            tmDBGPRINTEx(DEBUGLVL_TERSE,"Change VCO  inf %d\n\r", VCOnum_new);
        }
    }
    if ((err == TM_OK) && (VCOnum_new != VCOnum))
    {    /* VCO change needed */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_VCO_byte__VCO_Select, VCOnum_new, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));

        /* Wait LO_Lock timeout 20ms */
        counter = 20;
        while(counter > 0)
        {
            err = iTDA18275_Read(pObj, &gTDA18275_Reg_Power_state_byte_1__LO_Lock, &uVal, Bus_NoWrite);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Read(0x%08X) failed.", pObj->tUnitW));
            if(err==TM_OK && uVal==0x01)
            {
                /* PLL Lock */
                break;
            }
            if(counter)
            {
                /* Decrease the counter */
                counter--;

                /* Wait for a step of  1ms */
                err = iTDA18275_Wait(pObj, 1);
                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Wait(0x%08X) failed.", pObj->tUnitW));
            }
	    }
        if (err==TM_OK && counter==0)
        {  /* timeout LO_lock reached */
            err = TDA18275_ERR_NOT_READY;

            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_SetLO(0x%08X) 2nd timeout LO_lock reached.", pObj->tUnitW));
        }
        /* re Vtune sense */
        if(err == TM_OK)
        {
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_Power_Down_byte_1__PD_adc_vtune, 0x00, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
        }
        if(err == TM_OK)
        {
            err = iTDA18275_Read(pObj, &gTDA18275_Reg_vco_log__adc_vtune, &uVal, Bus_NoWrite);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
        }
        if(err == TM_OK)
        {
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_Power_Down_byte_1__PD_adc_vtune, 0x01, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
        }
    }
    /* Check temp & constraints on selected VCO to force or run normal VCO_Ampl_Cal */
    if((err == TM_OK) &&(uThermo > 75))
    {
         err = iTDA18275_Force_vco_currentctrl(pObj, uVal, VCOnum_new);
    }
    else
    {
        /* prepare VCO amp cal */
        /* adapt VCO swing Ctrl vs adc_vtune */
        if(err == TM_OK)
        {
            err = iTDA18275_Adapt_vco_swingctrl(pObj, uVal, VCOnum_new);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
        }
        if(err == TM_OK)
        {
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_VCO_cal_byte_1__VCOampl_force_cur, 0x00, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
        }
        /* run VCP amp */
        if(err == TM_OK)
        {
            err = iTDA18275_MSMLaunch(pObj, TDA18275_MSM_VCO_Ampl_Cal);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_SetMSM(0x%08X, TDA18275_MSM_HwInit) failed.", pObj->tUnitW));
        }
        if(err == TM_OK)
        {
            /* State reached after 10ms max */
            err = iTDA18275_WaitIRQ(pObj, 10, 1);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_WaitIRQ(0x%08X) failed.", pObj->tUnitW));
        }
    }
    /* Adapt CP vs adc_vtune / VCO select */
    if(err == TM_OK)
    {
        err = iTDA18275_AdaptICP(pObj, uVal, VCOnum_new);
    }

    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Reference_Byte__Dig_Clock, TDA18275_Dig_Clock_SubLO, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA18275_ProgramLPF                                          */
/*                                                                            */
/* DESCRIPTION: Sets Tuner Frequency registers.                               */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA18275_ProgramLPF(
    pTDA18275Object_t   pObj,   /* I: Driver object */
    UInt32 uIndex               /* I: index in the LU table */
)
{
    tmErrorCode_t err = TM_OK;
    UInt16 RF_LPF, RF_LPF_Feed ;

    RF_LPF = Code_Lu[uIndex].gnd ;
    RF_LPF_Feed = Code_Lu[uIndex].feed ;

    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_RF_Low_Pass_Filter_byte_1__RF_LPF_1, (UInt8)((RF_LPF&0x0FF0)>>4), Bus_None);  /* HI 8 RF_LPF */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_RF_Low_Pass_Filter_byte_2__RF_LPF_2, (UInt8)(RF_LPF&0x000F), Bus_None);  /* LO 4 RF_LPF */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_RF_Low_Pass_Filter_byte_3__RF_LPF_f_2, (UInt8)(RF_LPF_Feed&0x00FF), Bus_None); /*LO 8 RF_LPF_f */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_RF_Low_Pass_Filter_byte_2__RF_LPF_f_1, (UInt8)((RF_LPF_Feed&0x0F00)>>8), Bus_None); /* HI 4 RF_LPF_f */
    }

    if(err == TM_OK)
    {
        /* Write bytes RF_Low_Pass_Filter_byte_1 to RF_Low_Pass_Filter_byte_3 */
        err = iTDA18275_WriteRegMap(pObj, gTDA18275_Reg_RF_Low_Pass_Filter_byte_1.Address, TDA18275_REG_DATA_LEN(gTDA18275_Reg_RF_Low_Pass_Filter_byte_1, gTDA18275_Reg_RF_Low_Pass_Filter_byte_3));
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_WriteRegMap(0x%08X) failed.", pObj->tUnitW));
    }

    if( err == TM_OK)
    {
        /* store programmed value */
        pObj->uLUCodeProgrammed = uIndex;
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA18275_SetRF_Dependencies                                  */
/*                                                                            */
/* DESCRIPTION: Sets settings RF dependant                                    */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA18275_SetRF_Dependencies(
    pTDA18275Object_t   pObj   /* I: Driver object */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt8 uVal = 0;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_SetRF_Dependencies(0x%08X)", pObj->tUnitW);

        /* Set AGC1 TOP I2C DN/UP */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC1_byte_1__AGC1_Top, pObj->pStandard->AGC1_TOP_I2C_DN_UP, Bus_NoRead);

        /* Set  AGC2 TOP I2C DN/UP no write  */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC2_byte_1__AGC2_TOP, pObj->pStandard->AGC2_TOP_I2C_DN_UP, Bus_NoRead);

        /* Set  AGC1 TOP STRATEGY  */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC1_byte_1__AGC1_Top_Strategy, pObj->pStandard->AGC1_TOP_STRATEGY, Bus_NoRead);

        /* Set  AGC2 TOP STRATEGY, ! final write Reg_AGC2_byte_1  */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC2_byte_1__AGC2_Top_Strategy, pObj->pStandard->AGC2_Top_Strategy, Bus_NoRead);

        /* Set  AGC2 TOP adapt   */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Adapt_Top_byte__Top_adapt_AGC2, pObj->pStandard->AGC2_Adapt_TOP, Bus_NoRead);

        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Ovld_Udld_byte__Udld_Disable, 0x01, Bus_NoRead);  /* default Digital terrestrial */

    switch (pObj->StandardMode)
    {
        case TDA18275_QAM_6MHz:
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_Ovld_Udld_byte__Udld_Disable, 0x00, Bus_NoRead);

            if (pObj->uRF > 400000000)
            {
                /* Set AGC1 TOP I2C DN/UP */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC1_byte_1__AGC1_Top, TDA18275_AGC1_Top_102_96_dBuVrms, Bus_NoRead);
                /* Set  AGC2 TOP I2C DN/UP   */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC2_byte_1__AGC2_TOP, TDA18275_AGC2_TOP_104_103d5_99d5_dBuVrms, Bus_NoRead);
            }
            else
            {
                /* Set AGC1 TOP I2C DN/UP */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC1_byte_1__AGC1_Top, TDA18275_AGC1_Top_108_102_dBuVrms, Bus_NoRead);
                /* Set  AGC2 TOP I2C DN/UP   */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC2_byte_1__AGC2_TOP, TDA18275_AGC2_TOP_108_107d5_103d5_dBuVrms, Bus_NoRead);
                /* Set  AGC2 TOP adapt   */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_Adapt_Top_byte__Top_adapt_AGC2, TDA18275_Top_adapt_AGC2_n3_dB_TOP_for_IFLPF_gain_inf_9dB_12dB, Bus_NoRead);
            }
        break;
        case TDA18275_QAM_8MHz:

            err = iTDA18275_Write(pObj, &gTDA18275_Reg_Ovld_Udld_byte__Udld_Disable, 0x00, Bus_NoRead);

            if (pObj->uRF > 470000000)
            {
                /* Set AGC1 TOP I2C DN/UP */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC1_byte_1__AGC1_Top, TDA18275_AGC1_Top_102_96_dBuVrms, Bus_NoRead);
                /* Set  AGC2 TOP I2C DN/UP   */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC2_byte_1__AGC2_TOP, TDA18275_AGC2_TOP_105_104d5_100d5_dBuVrms, Bus_NoRead);
            }
            else if (pObj->uRF >= 200000000)
            {
                /* Set AGC1 TOP I2C DN/UP */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC1_byte_1__AGC1_Top, TDA18275_AGC1_Top_98_92_dBuVrms, Bus_NoRead);
                /* Set  AGC2 TOP I2C DN/UP   */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC2_byte_1__AGC2_TOP, TDA18275_AGC2_TOP_108_107d5_103d5_dBuVrms, Bus_NoRead);
                /* Set  AGC2 TOP adapt   */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_Adapt_Top_byte__Top_adapt_AGC2, TDA18275_Top_adapt_AGC2_n3_dB_TOP_for_IFLPF_gain_inf_9dB_12dB, Bus_NoRead);
            }
            else
            {
                /* Set  AGC2 TOP adapt   */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_Adapt_Top_byte__Top_adapt_AGC2, TDA18275_Top_adapt_AGC2_n3_dB_TOP_for_IFLPF_gain_inf_9dB_12dB, Bus_NoRead);
            }

        break;
        case TDA18275_ANLG_B:
        case TDA18275_ANLG_GH:
        case TDA18275_ANLG_I:
        case TDA18275_FM_Radio:
        case TDA18275_ANLG_MN:
        case TDA18275_ANLG_DK:
        case TDA18275_ANLG_L:
        case TDA18275_ANLG_LL:
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_Ovld_Udld_byte__Udld_Disable, 0x00, Bus_NoRead);
            if (pObj->StandardMode==TDA18275_ANLG_B && pObj->uRF < 100000000)
            {
                /* Set AGC1 TOP I2C DN/UP */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC1_byte_1__AGC1_Top, TDA18275_AGC1_Top_100_94_dBuVrms, Bus_NoRead);
                /* Set  AGC1 TOP STRATEGY  */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC1_byte_1__AGC1_Top_Strategy, TDA18275_AGC1_Top_Strategy_n4_dB_TOP_Do_for_LNA_gain_sup_16_dB, Bus_NoRead);
                /* Set  AGC2 TOP STRATEGY, ! final write Reg_AGC2_byte_1  */
                err = iTDA18275_Write(pObj, &gTDA18275_Reg_AGC2_byte_1__AGC2_Top_Strategy, TDA18275_AGC2_Top_Strategy_n1dB_n6dB_TOP_Do_for_LNA_gain_sup_10dB_16dB, Bus_NoRead);
            }
        break;
        default: break;
    }
    /* LNA High pass restriction : to be desactivated under 250MHz */
    err = iTDA18275_Read(pObj, &gTDA18275_Reg_RF_Filters_byte_1__LNA_Highpass, &uVal, Bus_None);
    if (pObj->uRF < 250000000 && uVal==TDA18275_LNA_Highpass_Enabled)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_RF_Filters_byte_1__LNA_Highpass, TDA18275_LNA_Highpass_Disabled, Bus_NoWrite);
    }

    return err;

}
/*============================================================================*/
/* FUNCTION:    iTDA18275_SetRF_Freq                                          */
/*                                                                            */
/* DESCRIPTION: Sets Tuner Frequency registers.                               */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA18275_SetRF_Freq(
    pTDA18275Object_t   pObj   /* I: Driver object */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt8 uVal=0;
    UInt8 index = 0;
    UInt32 fmax=0;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_SetRF_Freq(0x%08X)", pObj->tUnitW);

    /* settings standard RF dependant */
    if(err == TM_OK)
    {
        err = iTDA18275_SetRF_Dependencies(pObj);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_SetRF_Dependencies(0x%08X) failed.", pObj->tUnitW));
    }

    fmax = (pObj->uRF + pObj->pStandard->Offset_fmax) / 1000; /* in Khz */

    if (pObj->uRF > 333000000 &&  ( pObj->StandardMode==TDA18275_QAM_8MHz || pObj->StandardMode==TDA18275_QAM_6MHz ))
    {
        err = iTDA18275_ProgramLPF( pObj, 0 );
    }
    else
    {
        /* Get RCcal from HWinit */
        if(err == TM_OK)
        {
            err = iTDA18275_Read(pObj, &gTDA18275_Reg_RC_Cal_byte_2__RCcal, &uVal, Bus_None);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
        }

        /* Find RF_LPF[11:0] & RF_LPF_feed[11:0] table vs Rccal_read & RFfreq */
        do
        {
           index = index + 1;
        } while (( TDA18275_FilterRF[index-1].LO_upto < fmax ) && ( index < sizeof(TDA18275_FilterRF)/sizeof(TDA18275_FilterRFDef)));
        err = iTDA18275_ProgramLPF( pObj, TDA18275_FilterRF[index-1].Code_Lu_index[uVal]-1 );
    }

    /*  adapt IR_FreqPtr vs LO
        1:                  LO< 200MHz
        2: 200MHz =<LO<600MHz
        3: 600MHz =<LO<1GHz
    */
    if(err == TM_OK)
    {
        if (pObj->uLO < 200000000)
        {
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_IR_Cal_byte_3__IR_FreqPtr, 0x01, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
        }
        else if (pObj->uLO < 600000000)
        {
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_IR_Cal_byte_3__IR_FreqPtr, 0x02, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
        }
        else
        {
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_IR_Cal_byte_3__IR_FreqPtr, 0x03, Bus_NoRead);
           tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
        }
    }
    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA18275_AdaptICP                                         */
/*                                                                            */
/* DESCRIPTION: Overrides ICP.                                                */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
static tmErrorCode_t
iTDA18275_AdaptICP(
    pTDA18275Object_t   pObj,   /* I: Driver object */
    UInt8              uadc_vtune,     /* I: adc_vtune */
    UInt8 uVCO_select   /* I: VCO_select */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt8 uMinor=0, uMajor=0;
    UInt16  uIdentity=0;
    UInt8 vco_Adc_digital_icp_es1[3][8] = \
    { \
        {\
          TDA18275_cp_cursel_300_uA, \
          TDA18275_cp_cursel_300_uA, \
          TDA18275_cp_cursel_300_uA, \
          TDA18275_cp_cursel_420_uA, \
          TDA18275_cp_cursel_580_uA, \
          TDA18275_cp_cursel_800_uA, \
          TDA18275_cp_cursel_800_uA, \
          TDA18275_cp_cursel_1100_uA \
        }, \
        { \
          TDA18275_cp_cursel_300_uA, \
          TDA18275_cp_cursel_300_uA, \
          TDA18275_cp_cursel_300_uA, \
          TDA18275_cp_cursel_420_uA, \
          TDA18275_cp_cursel_580_uA, \
          TDA18275_cp_cursel_800_uA, \
          TDA18275_cp_cursel_800_uA, \
          TDA18275_cp_cursel_1100_uA \
        }, \
        { \
          TDA18275_cp_cursel_300_uA, \
          TDA18275_cp_cursel_300_uA, \
          TDA18275_cp_cursel_300_uA, \
          TDA18275_cp_cursel_420_uA, \
          TDA18275_cp_cursel_580_uA, \
          TDA18275_cp_cursel_800_uA, \
          TDA18275_cp_cursel_1100_uA, \
          TDA18275_cp_cursel_1100_uA \
        }
    };
    UInt8 vco_Adc_digital_icp[3][8] = \
    { \
        {\
          TDA18275_cp_cursel_300_uA, \
          TDA18275_cp_cursel_300_uA, \
          TDA18275_cp_cursel_420_uA, \
          TDA18275_cp_cursel_580_uA, \
          TDA18275_cp_cursel_800_uA, \
          TDA18275_cp_cursel_800_uA, \
          TDA18275_cp_cursel_1100_uA, \
          TDA18275_cp_cursel_1100_uA \
        }, \
        { \
          TDA18275_cp_cursel_300_uA, \
          TDA18275_cp_cursel_300_uA, \
          TDA18275_cp_cursel_300_uA, \
          TDA18275_cp_cursel_420_uA, \
          TDA18275_cp_cursel_800_uA, \
          TDA18275_cp_cursel_800_uA, \
          TDA18275_cp_cursel_1100_uA, \
          TDA18275_cp_cursel_1100_uA \
        }, \
        { \
          TDA18275_cp_cursel_300_uA, \
          TDA18275_cp_cursel_300_uA, \
          TDA18275_cp_cursel_420_uA, \
          TDA18275_cp_cursel_420_uA, \
          TDA18275_cp_cursel_580_uA, \
          TDA18275_cp_cursel_800_uA, \
          TDA18275_cp_cursel_1100_uA, \
          TDA18275_cp_cursel_1100_uA \
        }
    };
    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_AdaptICP(0x%08X)", pObj->tUnitW);

    if (pObj->pStandard->cp_cursel_algo == TDA18275_cp_cursel_Analog)
    {
        /*  Analog Standards
          vtune_adc     cp_cursel
            0              0 :60u
            1              0: 60u
            2              0: 60u
            3              0: 60u
            4              0: 60u
            5              0: 60u
            6              1: 150u
            7              1: 150u

        */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Charge_pump_byte__cpleak0, (uadc_vtune < 6 )? 0x01 : 0x00 , Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Charge_pump_byte__cp_cursel, (uadc_vtune < 6 )? 0 : 1, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    else if (pObj->pStandard->cp_cursel_algo == TDA18275_cp_cursel_Digital)
    {
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_ID_byte_3__Minor_rev, &uMinor, Bus_None );
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_ID_byte_3__Major_rev, &uMajor, Bus_None );
        err = iTDA18275_GetIdentity(pObj, &uIdentity);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Charge_pump_byte__cpleak0, 0x00 , Bus_None);
        if (uIdentity== TDA18275_Identity && uMajor==1 && (uMinor <= 2 || uMinor==4))
        { /*  ES1a, ES1b, ES1c, ES1a_MF */
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_Charge_pump_byte__cp_cursel, vco_Adc_digital_icp_es1[uVCO_select][uadc_vtune], Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
        }
        else
        {
            err = iTDA18275_Write(pObj, &gTDA18275_Reg_Charge_pump_byte__cp_cursel, vco_Adc_digital_icp[uVCO_select][uadc_vtune], Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
        }
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA18275_SetPLL                                              */
/*                                                                            */
/* DESCRIPTION: Set the PLL in manual mode                                    */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
extern tmErrorCode_t
iTDA18275_SetPLL(
    pTDA18275Object_t   pObj    /* I: Driver object */
)
{
    tmErrorCode_t err = TM_OK;

    /* Algorithm that calculates N, K */
    UInt32 N_int = 0;
    UInt32 K_int = 0;
    /* SUB_LO prog */
    UInt8 Nsub=0, Nsub_floor=0, Nsub_ceiling=0;
    UInt32 Nsub_err_mhz_floor=0, Nsub_err__mhz_ceiling=0;
    Bool out_of_16Mhz[TDA18275_StandardMode_Max] = { False, False, False, False, False, False, False, False, False, False,
        False, False, True, True, True, True, True, False, False };

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_SetPLL(0x%08X)", pObj->tUnitW);

    if(err == TM_OK)
    {
        /* Calculate N & K values of the PLL */
        err = iTDA18275_CalculateNIntKInt(pObj, &N_int, &K_int);
    }

    /* Affect registers map without writing to IC ( only Nfrac High and medium part , Low in HW) */
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Sigma_delta_byte_2__LO_Frac_2, (UInt8)((K_int >> 16) & 0xFF), Bus_None);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Sigma_delta_byte_3__LO_Frac_1, (UInt8)((K_int >> 8) & 0xFF), Bus_None);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }

    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Sigma_delta_byte_1__LO_Int, (UInt8)(N_int & 0xFF), Bus_None);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }

    if(err == TM_OK)
    {
        /* Write bytes Sigma_delta_byte_1 to Sigma_delta_byte_3  */
        err = iTDA18275_WriteRegMap(pObj, gTDA18275_Reg_Sigma_delta_byte_1.Address, TDA18275_REG_DATA_LEN(gTDA18275_Reg_Sigma_delta_byte_1, gTDA18275_Reg_Sigma_delta_byte_3));
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }

    /* program SUBLO  fct ( LO ) :  calculate Nsub to keep Fsub as close as possible of 16 Mhz*/
    Nsub_floor = (UInt8)(pObj->uLO / 16000000);
    Nsub_ceiling = Nsub_floor + 1;

    // check value to avoid div by zero
    if(Nsub_floor == 0)
    {
        err = TDA18275_ERR_BAD_PARAMETER;
    }

    if( err == TM_OK )
    {
        Nsub_err_mhz_floor = (pObj->uLO / Nsub_floor ) - 16000000 ;
        Nsub_err__mhz_ceiling = 16000000 - (pObj->uLO / Nsub_ceiling);
        Nsub = (Nsub_err_mhz_floor < Nsub_err__mhz_ceiling ? Nsub_floor : Nsub_ceiling);
    }

    /* exlude subLO too near 16Mhz in range of 10 Khz (if resquested in the current standard) */
    if( err == TM_OK && out_of_16Mhz[pObj->StandardMode] == True )
    {
        if (Nsub_err_mhz_floor  < 10000 || Nsub_err__mhz_ceiling < 10000)
        {
            Nsub = Nsub +1;
            tmDBGPRINTEx(DEBUGLVL_TERSE, "LO %d PAL SubLO change : %d vs %d ", pObj->uLO, pObj->uLO / Nsub, pObj->uLO / (Nsub-1));
        }
        /* STANDARD NTSC : exlude subLO  16.120 Mhz +/- 20 Khz */
        else if (pObj->StandardMode == TDA18275_ANLG_MN)
        {
            if ( pObj->uLO / Nsub > 16100000 &&  pObj->uLO / Nsub < 16140000)
            {
                Nsub = Nsub +1;
                tmDBGPRINTEx(DEBUGLVL_TERSE, "LO %d NTSC SubLO change : %d vs %d ", pObj->uLO, pObj->uLO / Nsub, pObj->uLO / (Nsub-1));
            }
        }
    }

    if(err == TM_OK)
    {   /* SUBLO_prog = Nsub - 2 */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Sublo_byte__SUBLO_prog, Nsub - 2, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
    }
    /* launch synchro */
    if(err == TM_OK)
    {
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_Sigma_prog_byte__Update_prg, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
        err = err | iTDA18275_Write(pObj, &gTDA18275_Reg_Sigma_prog_byte__Update_prg, 0x00, Bus_None);
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA18275_CalculateNIntKInt                                   */
/*                                                                            */
/* DESCRIPTION: Calculate PLL N & K values                                    */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
static tmErrorCode_t
iTDA18275_CalculateNIntKInt(
    pTDA18275Object_t   pObj,    /* I: Driver object */
    UInt32* NInt,
    UInt32* KInt
)
{
    tmErrorCode_t err = TM_OK;

    /* Algorithm that calculates N_K */
    UInt32 N_K_prog = 0;

    /* Algorithm that calculates N, K corrected */
    UInt32 Nprime = 0;
    UInt32 KforceK0_1 = 0;
    UInt32 K2msb = 0;
    UInt32 N0 = 0;
    UInt32 Nm1 = 0;

    /* Calculate N_K_Prog */
    N_K_prog = (pObj->uFVCO * 128) / 125;

    /* Calculate N & K corrected values */
    Nprime = N_K_prog & 0xFF0000;

    /* Force LSB to 1 */
    KforceK0_1 = 2*(((N_K_prog - Nprime) << 7) / 2) + 1;

    /* Check MSB bit around 2 */
    K2msb = KforceK0_1 >> 21;
    if (K2msb < 1)
    {
        N0 = 1;
    }
    else
    {
        if (K2msb >= 3)
        {
            N0 = 1;
        }
        else
        {
            N0 = 0;
        }
    }
    if (K2msb < 1)
    {
        Nm1 = 1;
    }
    else
    {
        Nm1 = 0;
    }

    /* Calculate N */
    *NInt = (2 * ((Nprime >> 16) - Nm1) + N0) - 128;

    /* Calculate K */
    if (K2msb < 1)
    {
        *KInt = KforceK0_1 + (2 << 21);
    }
    else
    {
        if (K2msb >= 3)
        {
            *KInt = KforceK0_1 - (2 << 21);
        }
        else
        {
            *KInt = KforceK0_1;
        }
    }

    /* Force last 7 bits of K_int to 0x5D, as the IC is doing for spurs optimization */
    *KInt &= 0xFFFFFF80;
    /* *KInt |= 0x5D; done by HW */

    return err;
}
/*============================================================================*/
/* FUNCTION:    iTDA18275_Adapt_vco_swingctrl                                 */
/*                                                                            */
/* DESCRIPTION: Adapt VCO swing vs adc vtune                                  */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
extern tmErrorCode_t
iTDA18275_Adapt_vco_swingctrl(
    pTDA18275Object_t   pObj,   /* I: Driver object */
    UInt8  adc_vtune,
    UInt8   VCO_select
)
{
    tmErrorCode_t err = TM_OK;
    UInt8 uMinor=0, uMajor=0;
    UInt16  uIdentity=0;
    UInt8 vco_swingctrl_Adc_es1[3][8] = \
    { \
        {\
          TDA18275_VCO_swingctrl_320_mV, \
          TDA18275_VCO_swingctrl_360_mV, \
          TDA18275_VCO_swingctrl_380_mV, \
          TDA18275_VCO_swingctrl_420_mV, \
          TDA18275_VCO_swingctrl_520_mV, \
          TDA18275_VCO_swingctrl_560_mV, \
          TDA18275_VCO_swingctrl_560_mV, \
          TDA18275_VCO_swingctrl_560_mV \
        }, \
        { \
          TDA18275_VCO_swingctrl_240_mV, \
          TDA18275_VCO_swingctrl_280_mV, \
          TDA18275_VCO_swingctrl_280_mV, \
          TDA18275_VCO_swingctrl_320_mV, \
          TDA18275_VCO_swingctrl_380_mV, \
          TDA18275_VCO_swingctrl_420_mV, \
          TDA18275_VCO_swingctrl_420_mV, \
          TDA18275_VCO_swingctrl_480_mV \
        }, \
        { \
          TDA18275_VCO_swingctrl_200_mV, \
          TDA18275_VCO_swingctrl_240_mV, \
          TDA18275_VCO_swingctrl_240_mV, \
          TDA18275_VCO_swingctrl_280_mV, \
          TDA18275_VCO_swingctrl_360_mV, \
          TDA18275_VCO_swingctrl_380_mV, \
          TDA18275_VCO_swingctrl_400_mV, \
          TDA18275_VCO_swingctrl_420_mV \
        }
    };
    UInt8 vco_swingctrl_Adc[3][8] = \
    { \
        {\
          TDA18275_VCO_swingctrl_320_mV, \
          TDA18275_VCO_swingctrl_360_mV, \
          TDA18275_VCO_swingctrl_380_mV, \
          TDA18275_VCO_swingctrl_420_mV, \
          TDA18275_VCO_swingctrl_480_mV, \
          TDA18275_VCO_swingctrl_520_mV, \
          TDA18275_VCO_swingctrl_520_mV, \
          TDA18275_VCO_swingctrl_520_mV \
        }, \
        { \
          TDA18275_VCO_swingctrl_280_mV, \
          TDA18275_VCO_swingctrl_320_mV, \
          TDA18275_VCO_swingctrl_360_mV, \
          TDA18275_VCO_swingctrl_380_mV, \
          TDA18275_VCO_swingctrl_420_mV, \
          TDA18275_VCO_swingctrl_460_mV, \
          TDA18275_VCO_swingctrl_520_mV, \
          TDA18275_VCO_swingctrl_520_mV \
        }, \
        { \
          TDA18275_VCO_swingctrl_280_mV, \
          TDA18275_VCO_swingctrl_280_mV, \
          TDA18275_VCO_swingctrl_320_mV, \
          TDA18275_VCO_swingctrl_320_mV, \
          TDA18275_VCO_swingctrl_380_mV, \
          TDA18275_VCO_swingctrl_460_mV, \
          TDA18275_VCO_swingctrl_480_mV, \
          TDA18275_VCO_swingctrl_520_mV \
        }
    };
    if(err == TM_OK)
    {
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_ID_byte_3__Minor_rev, &uMinor, Bus_None );
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_ID_byte_3__Major_rev, &uMajor, Bus_None );
        err = iTDA18275_GetIdentity(pObj, &uIdentity);
        if (uIdentity== TDA18275_Identity && uMajor==1 && (uMinor <= 2 || uMinor==4))
        { /*  ES1a, ES1b, ES1c, ES1a_MF */
  	        err = iTDA18275_Write(pObj, &gTDA18275_Reg_VCO_cal_byte_2__VCO_swingctrl, vco_swingctrl_Adc_es1[VCO_select][adc_vtune], Bus_NoRead);
	        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
        }
        else
        {   /* normal coding in other versions ES1' and further */
  	        err = iTDA18275_Write(pObj, &gTDA18275_Reg_VCO_cal_byte_2__VCO_swingctrl, vco_swingctrl_Adc[VCO_select][adc_vtune], Bus_NoRead);
	        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
        }
    }

    return err;
}
/*============================================================================*/
/* FUNCTION:    iTDA18275_Force_vco_currentctrl                               */
/*                                                                            */
/* DESCRIPTION: Force lvco instead of auto cal VCO_Ampl                       */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
extern tmErrorCode_t
iTDA18275_Force_vco_currentctrl(
    pTDA18275Object_t   pObj,   /* I: Driver object */
    UInt8  adc_vtune,
    UInt8   VCO_select
)
{
    tmErrorCode_t err = TM_OK;
    UInt8 vcocur_Adc[3][8] = \
    { \
        {\
          8, \
          9, \
          10, \
          11, \
          12, \
          12, \
          13, \
          13 \
        }, \
        { \
          7, \
          7, \
          8, \
          8, \
          9, \
          10, \
          10, \
          11 \
        }, \
        { \
          5, \
          5, \
          6, \
          6, \
          7, \
          8, \
          8, \
          9 \
        }
    };

    err = iTDA18275_Write(pObj, &gTDA18275_Reg_VCO_cal_byte_1__VCOampl_force_cur, 0x01, Bus_None);
  	err = iTDA18275_Write(pObj, &gTDA18275_Reg_VCO_cal_byte_1__VCO_currentctrl, vcocur_Adc[VCO_select][adc_vtune], Bus_NoRead);
	tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));

    return err;
}
/*============================================================================*/
/* FUNCTION:    iTDA18275_MSMLaunch                                              */
/*                                                                            */
/* DESCRIPTION: clear IRQ, launch MSM                                         */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA18275_MSMLaunch(
    pTDA18275Object_t   pObj,   /* I: Driver object */
    UInt8           uCalMask /* I: list of Cal to permform */
)
{
    tmErrorCode_t   err = TM_OK;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_SetMSM(0x%08X)", pObj->tUnitW);

    if(err == TM_OK)
    {
		/* clear all IRQ */
		err = iTDA18275_Write(pObj, &gTDA18275_Reg_IRQ_clear, 0xFE, Bus_NoRead);
		tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Write(0x%08X) failed.", pObj->tUnitW));
	}

    if(err == TM_OK)
    {
        /* Set state machine and Launch it */
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_MSM_byte_1, uCalMask, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_MSM_byte_2__MSM_Launch, 0x01, Bus_None);
        err = iTDA18275_WriteRegMap(pObj, gTDA18275_Reg_MSM_byte_1.Address, 0x02);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_WriteRegMap(0x%08X) failed.", pObj->tUnitW));
        err = err | iTDA18275_Write(pObj, &gTDA18275_Reg_MSM_byte_2__MSM_Launch, 0x00, Bus_None);
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA18275_WaitIRQ                                             */
/*                                                                            */
/* DESCRIPTION: Wait the IRQ to trigger                                       */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA18275_WaitIRQ(
    pTDA18275Object_t   pObj,       /* I: Driver object */
    UInt32              timeOut,    /* I: timeout */
    UInt32              waitStep   /* I: wait step */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt32          counter = timeOut/waitStep; /* Wait max timeOut/waitStep ms */
    UInt8           uIRQ = 0;
    Bool            bIRQTriggered = False;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_WaitIRQ(0x%08X)", pObj->tUnitW);

    while(err == TM_OK && (counter--)>0)
    {
        err = iTDA18275_Read(pObj, &gTDA18275_Reg_IRQ_status__IRQ_status, &uIRQ, Bus_RW);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Read(0x%08X) failed.", pObj->tUnitW));

        if(err == TM_OK && uIRQ == 1)
        {
            bIRQTriggered = True;
            break;
        }

        if(counter)
        {
            err = iTDA18275_Wait(pObj, waitStep);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_Wait(0x%08X) failed.", pObj->tUnitW));
        }
    }

    if(err == TM_OK && bIRQTriggered == False)
    {
        err = TDA18275_ERR_NOT_READY;
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA18275_Write                                               */
/*                                                                            */
/* DESCRIPTION: Writes in TDA18275 hardware                                   */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA18275_Write(
    pTDA18275Object_t           pObj,       /* I: Driver object */
    const TDA18275_BitField_t*  pBitField, /* I: Bitfield structure */
    UInt8                       uData,      /* I: Data to write */
    tmbslFrontEndBusAccess_t                eBusAccess  /* I: Access to bus */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt8           RegAddr = 0;
    UInt32          DataLen = 1;
    UInt8           RegData = 0;
    pUInt8          pRegData = Null;
    UInt32          RegMask = 0;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_Write(0x%08X)", pObj->tUnitW);

    if(pBitField == Null)
    {
        err = TDA18275_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        /* Set Register Address */
        RegAddr = pBitField->Address;

        if(RegAddr < TDA18275_REG_MAP_NB_BYTES)
        {
            pRegData = (UInt8 *)(&(pObj->RegMap)) + RegAddr;
        }
        else
        {
            pRegData = &RegData;
        }

        if( (eBusAccess&Bus_NoRead) == False && P_SIO_READ_VALID)
        {
            /* Read data from TDA18275 */
            err = P_SIO_READ(pObj->tUnitW, TDA18275_REG_ADD_SZ, &RegAddr, DataLen, pRegData);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "IO_Read(0x%08X, 1, 0x%02X, %ld) failed.", pObj->tUnitW, RegAddr, DataLen));
        }

        if(err == TM_OK)
        {
            RegMask = ( (1 << pBitField->WidthInBits) - 1);
            /* Limit uData to WidthInBits */
            uData &= RegMask;

            /* Set Data */
            RegMask = RegMask << pBitField->PositionInBits;
            *pRegData &= (UInt8)(~RegMask);
            *pRegData |= uData << pBitField->PositionInBits;

            if( (eBusAccess&Bus_NoWrite) == False && P_SIO_WRITE_VALID)
            {
                /* Write data to TDA18275 */
                err = P_SIO_WRITE(pObj->tUnitW, TDA18275_REG_ADD_SZ, &RegAddr, DataLen, pRegData);
                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "IO_Write(0x%08X, 1, 0x%02X, %ld) failed.", pObj->tUnitW, RegAddr, DataLen));
            }
        }
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA18275_Read                                                */
/*                                                                            */
/* DESCRIPTION: Reads in TDA18275 hardware                                    */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA18275_Read(
    pTDA18275Object_t           pObj,       /* I: Driver object */
    const TDA18275_BitField_t*  pBitField, /* I: Bitfield structure */
    UInt8*                      puData,     /* I: Data to read */
    tmbslFrontEndBusAccess_t                eBusAccess  /* I: Access to bus */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt8           RegAddr = 0;
    UInt32          DataLen = 1;
    UInt8           RegData = 0;
    pUInt8          pRegData = Null;
    UInt32          RegMask = 0;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_Read(0x%08X)", pObj->tUnitW);

    if(pBitField == Null)
    {
        err = TDA18275_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        /* Set Register Address */
        RegAddr = pBitField->Address;

        if(RegAddr < TDA18275_REG_MAP_NB_BYTES)
        {
            pRegData = (UInt8 *)(&(pObj->RegMap)) + RegAddr;
        }
        else
        {
            pRegData = &RegData;
        }

        if( (eBusAccess&Bus_NoRead) == False && P_SIO_READ_VALID)
        {
            /* Read data from TDA18275 */
            err = P_SIO_READ(pObj->tUnitW, TDA18275_REG_ADD_SZ, &RegAddr, DataLen, pRegData);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "IO_Read(0x%08X, 1, 0x%02X, %ld) failed.", pObj->tUnitW, RegAddr, DataLen));
        }

        if(err == TM_OK && puData != Null)
        {
            /* Copy Raw Data */
            *puData = *pRegData;

            /* Get Data */
            RegMask = ( (1 << pBitField->WidthInBits) - 1) << pBitField->PositionInBits;
            *puData &= (UInt8)RegMask;
            *puData = (*puData) >> pBitField->PositionInBits;
        }
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA18275_WriteRegMap                                         */
/*                                                                            */
/* DESCRIPTION: Writes driver RegMap cached data to TDA18275 hardware.        */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA18275_WriteRegMap(
    pTDA18275Object_t   pObj,       /* I: Driver object */
    UInt8               uAddress,   /* I: Data to write */
    UInt32              uWriteLen   /* I: Number of data to write */
)
{
    tmErrorCode_t   err = TM_OK;
    pUInt8          pRegData = Null;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_WriteRegMap(0x%08X)", pObj->tUnitW);

    if( uAddress < TDA18275_REG_MAP_NB_BYTES &&
        (uAddress + uWriteLen) <= TDA18275_REG_MAP_NB_BYTES )
    {
        pRegData = (UInt8 *)(&(pObj->RegMap)) + uAddress;
    }
    else
    {
        err = TDA18275_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK && P_SIO_WRITE_VALID)
    {
        /* Write data to TDA18275 */
        err = P_SIO_WRITE(pObj->tUnitW, TDA18275_REG_ADD_SZ, &uAddress, uWriteLen, pRegData);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "IO_Write(0x%08X, 1, 0x%02X, %ld) failed.", pObj->tUnitW, uAddress, uWriteLen));
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA18275_ReadRegMap                                          */
/*                                                                            */
/* DESCRIPTION: Reads driver RegMap cached data from TDA18275 hardware.       */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA18275_ReadRegMap(
    pTDA18275Object_t   pObj,       /* I: Driver object */
    UInt8               uAddress,   /* I: Data to read */
    UInt32              uReadLen    /* I: Number of data to read */
)
{
    tmErrorCode_t   err = TM_OK;
    pUInt8          pRegData = Null;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_ReadRegMap(0x%08X)", pObj->tUnitW);

    if( uAddress < TDA18275_REG_MAP_NB_BYTES &&
       (uAddress + uReadLen) <= TDA18275_REG_MAP_NB_BYTES )
    {
        pRegData = (UInt8 *)(&(pObj->RegMap)) + uAddress;
    }
    else
    {
        err = TDA18275_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK && P_SIO_READ_VALID)
    {
        /* Read data from TDA18275 */
        err = P_SIO_READ(pObj->tUnitW, TDA18275_REG_ADD_SZ, &uAddress, uReadLen, pRegData);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "IO_Read(0x%08X, 1, 0x%02X, %ld) failed.", pObj->tUnitW, uAddress, uReadLen));
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA18275_Wait                                                */
/*                                                                            */
/* DESCRIPTION: Waits for requested time.                                     */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA18275_Wait(
    pTDA18275Object_t   pObj,   /* I: Driver object */
    UInt32              Time    /* I: time to wait for */
)
{
    tmErrorCode_t   err = TDA18275_ERR_NULL_CONTROLFUNC;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_Wait(0x%08X)", pObj->tUnitW);

    if(P_STIME_WAIT_VALID)
    {
        /* Wait Time ms */
        err = P_STIME_WAIT(pObj->tUnitW, Time);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TIME_Wait(0x%08X, %ld) failed.", pObj->tUnitW, Time));
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA18275_PowerSavingMode                                     */
/*                                                                            */
/* DESCRIPTION: set registers according  the  PowerSavingMode                 */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA18275_PowerSavingMode(
    pTDA18275Object_t   pObj,   /* I: Driver object */
    TDA18275PowerSavingMode_t  PowerSavingMode    /* I: time to wait for */
)
{
    tmErrorCode_t   err = TDA18275_ERR_NULL_CONTROLFUNC;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_Wait(0x%08X)", pObj->tUnitW);

	if (PowerSavingMode == TDA18275PowerSavingMode_Digital_nominal)
	{
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_1__PSM_LNA, TDA18275_PSM_LNA_n10_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_1__PSM_AGC2, TDA18275_PSM_AGC2_n11_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_1__PSM_Det2, TDA18275_PSM_Det2_n3_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_2__PSM_RF_LPF, TDA18275_PSM_RF_LPF_n7_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_1__PSM_LoMixer, TDA18275_PSM_LoMixer_3_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__PSM_Lodriver, TDA18275_PSM_Lodriver_n6_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__PSM_Mixer, TDA18275_PSM_Mixer_n3_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__LOdiv4_Boost, TDA18275_LOdiv4_Boost_0_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_2__Loch_curr_boost, TDA18275_Loch_curr_boost_0, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__PSM_Ifpoly, TDA18275_PSM_Ifpoly_n3d2_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_2__PSM_IFfilter, TDA18275_PSM_IFfilter_n8d9_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_2__PSM_IFLPF, TDA18275_PSM_IFLPF_n4d9_mA, Bus_None);
	}
	else if (PowerSavingMode == TDA18275PowerSavingMode_Analog_nominal)
	{
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_1__PSM_LNA, TDA18275_PSM_LNA_n10_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_1__PSM_AGC2, TDA18275_PSM_AGC2_n11_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_1__PSM_Det2, TDA18275_PSM_Det2_n3_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_2__PSM_RF_LPF, TDA18275_PSM_RF_LPF_0_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_1__PSM_LoMixer, TDA18275_PSM_LoMixer_3_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__PSM_Lodriver, TDA18275_PSM_Lodriver_n6_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__PSM_Mixer, TDA18275_PSM_Mixer_n3_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__LOdiv4_Boost, TDA18275_LOdiv4_Boost_0_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_2__Loch_curr_boost, TDA18275_Loch_curr_boost_0, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__PSM_Ifpoly, TDA18275_PSM_Ifpoly_n3d2_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_2__PSM_IFfilter, TDA18275_PSM_IFfilter_n8d9_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_2__PSM_IFLPF, TDA18275_PSM_IFLPF_0_mA, Bus_None);
	}
	else if (PowerSavingMode == TDA18275PowerSavingMode_QAM_nominal)
	{
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_1__PSM_LNA, TDA18275_PSM_LNA_n10_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_1__PSM_AGC2, TDA18275_PSM_AGC2_n8_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_1__PSM_Det2, TDA18275_PSM_Det2_n1_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_2__PSM_RF_LPF, TDA18275_PSM_RF_LPF_0_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_1__PSM_LoMixer, TDA18275_PSM_LoMixer_3_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__PSM_Lodriver, TDA18275_PSM_Lodriver_n6_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__PSM_Mixer, TDA18275_PSM_Mixer_n3_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__LOdiv4_Boost, TDA18275_LOdiv4_Boost_0_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_2__Loch_curr_boost, TDA18275_Loch_curr_boost_0, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__PSM_Ifpoly, TDA18275_PSM_Ifpoly_n3d2_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_2__PSM_IFfilter, TDA18275_PSM_IFfilter_n8d9_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_2__PSM_IFLPF, TDA18275_PSM_IFLPF_n4d9_mA, Bus_None);
	}
	else if (PowerSavingMode == TDA18275PowerSavingMode_ATSC_nominal)
	{
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_1__PSM_LNA, TDA18275_PSM_LNA_n10_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_1__PSM_AGC2, TDA18275_PSM_AGC2_n11_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_1__PSM_Det2, TDA18275_PSM_Det2_n3_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_2__PSM_RF_LPF, TDA18275_PSM_RF_LPF_0_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_1__PSM_LoMixer, TDA18275_PSM_LoMixer_3_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__PSM_Lodriver, TDA18275_PSM_Lodriver_n6_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__PSM_Mixer, TDA18275_PSM_Mixer_0_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__LOdiv4_Boost, TDA18275_LOdiv4_Boost_1d8_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_2__Loch_curr_boost, TDA18275_Loch_curr_boost_0, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_3__PSM_Ifpoly, TDA18275_PSM_Ifpoly_0_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_2__PSM_IFfilter, TDA18275_PSM_IFfilter_0_mA, Bus_None);
        err = iTDA18275_Write(pObj, &gTDA18275_Reg_PowerSavingMode_byte_2__PSM_IFLPF, TDA18275_PSM_IFLPF_n4d9_mA, Bus_None);
    }
    if(err == TM_OK)
    {
        /* Write gTDA18275_Reg_PowerSavingMode_byte_1 to gTDA18275_Reg_PowerSavingMode_byte_3  Registers */
        err = iTDA18275_WriteRegMap(pObj, gTDA18275_Reg_PowerSavingMode_byte_1.Address, TDA18275_REG_DATA_LEN(gTDA18275_Reg_PowerSavingMode_byte_1, gTDA18275_Reg_PowerSavingMode_byte_3));
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA18275_WriteRegMap(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        pObj->curPowerSavingMode = PowerSavingMode;
    }


	return err;
}
/*============================================================================*/
/* FUNCTION:    iTDA18275_GetIdentity                                         */
/*                                                                            */
/* DESCRIPTION:  returns  Tuner Identity                                      */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA18275_GetIdentity(
    pTDA18275Object_t   pObj,   /* I: Driver object */
    UInt16*  puIdentity    /* O: numerical identity  */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt8               ID_byte_1 = 0;
    UInt8               ID_byte_2 = 0;

    err = iTDA18275_Read(pObj, &gTDA18275_Reg_ID_byte_1__Ident_1, &ID_byte_1, Bus_None);
    err = iTDA18275_Read(pObj, &gTDA18275_Reg_ID_byte_2__Ident_2, &ID_byte_2, Bus_None);
    /* Construct Identity */
    *puIdentity = (ID_byte_1 << 8) | ID_byte_2;
    return err;
}

#ifdef _TVFE_IMPLEMENT_MUTEX

/*============================================================================*/
/* FUNCTION:    iTDA18275_MutexAcquire:                                       */
/*                                                                            */
/* DESCRIPTION: Acquires driver mutex.                                        */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*============================================================================*/
tmErrorCode_t
iTDA18275_MutexAcquire(
    pTDA18275Object_t   pObj,
    UInt32              timeOut
)
{
    tmErrorCode_t   err = TDA18275_ERR_NULL_CONTROLFUNC;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_MutexAcquire(0x%08X)", pObj->tUnitW);

    if(P_SMUTEX_ACQUIRE_VALID && P_MUTEX_VALID)
    {
        err = P_SMUTEX_ACQUIRE(P_MUTEX, timeOut);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "Mutex_Acquire(0x%08X, %ld) failed.", pObj->tUnitW, timeOut));
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA18275_MutexRelease:                                       */
/*                                                                            */
/* DESCRIPTION: Releases driver mutex.                                        */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*============================================================================*/
tmErrorCode_t
iTDA18275_MutexRelease(
    pTDA18275Object_t   pObj
)
{
    tmErrorCode_t   err = TDA18275_ERR_NULL_CONTROLFUNC;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA18275_MutexRelease(0x%08X)", pObj->tUnitW);

    if(P_SMUTEX_RELEASE_VALID && P_MUTEX_VALID)
    {
        err = P_SMUTEX_RELEASE(P_MUTEX);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "Mutex_Release(0x%08X) failed.", pObj->tUnitW));
    }

    return err;
}
#endif




